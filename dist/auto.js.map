{"mappings":"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","sources":["./src/index.js","./src/get_overflowing_range.js","./src/generators/break_point_generator.js","./src/generators/node_generator.js","./src/caches/rect_filter_cache.js","./src/break_points/base_break_point.js","./src/generators/line_box_generator.js","./src/break_points/inline_break_point.js","./src/break_points/sibling_break_point.js","./src/caches/node_rule_cache.js","./src/generators/rule_disabler_generator.js","./src/parse_page_size.js","./src/extract.js","./src/uuid.js","./src/extractors/table_extractor.js","./src/extractors/list_extractor.js","./src/extractors/fragmented_extractor.js","./src/auto.js"],"sourcesContent":["import { getOverflowingRange } from './get_overflowing_range';\nimport { parsePageSize } from './parse_page_size';\nimport { extract } from './extract';\n\nfunction newPage({ footer, header, pageNumber }) {\n  const page = document.createElement('div');\n  page.classList.add('page');\n  page.setAttribute('role', 'region');\n  page.setAttribute('aria-label', `Page ${pageNumber}`);\n  page.setAttribute('data-page-number', pageNumber);\n  page.style.setProperty('--page-number', pageNumber);\n  document.body.appendChild(page);\n  const pageInner = document.createElement('div');\n  pageInner.classList.add('page-inner');\n  page.appendChild(pageInner);\n\n  if (header) {\n    const pageHeader = document.createElement('div');\n    pageHeader.classList.add('page-header');\n    pageInner.appendChild(pageHeader);\n    pageHeader.appendChild(header.cloneNode(true));\n  }\n\n  const pageContent = document.createElement('div');\n  pageContent.classList.add('page-content');\n  pageInner.appendChild(pageContent);\n\n  if (footer) {\n    const pageFooter = document.createElement('div');\n    pageFooter.classList.add('page-footer');\n    pageInner.appendChild(pageFooter);\n    pageFooter.appendChild(footer.cloneNode(true));\n  }\n  return pageContent;\n}\n\nfunction childrenToFragment(node) {\n  const fragment = document.createDocumentFragment();\n  Array.from(node.childNodes).forEach((child) => {\n    fragment.appendChild(child);\n  });\n  return fragment;\n}\n\nfunction getStartingContent() {\n  const main = document.querySelector('body > main');\n  const content = childrenToFragment(main || document.body);\n  main?.remove();\n  return content;\n}\n\nfunction extractSelector(selector) {\n  const node = document.querySelector(selector);\n  if (node) {\n    return childrenToFragment(node);\n  }\n  return null;\n}\n\nfunction emptyFragment(node) {\n  return !node.hasChildNodes()\n    || (node.childNodes.length === 1\n      && node.firstChild.nodeType === Node.TEXT_NODE\n      && !node.firstChild.data.trim()\n    );\n}\n\nfunction emptyRange(range) {\n  if (!range || range.collapsed || emptyFragment(range.cloneContents())) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Move the content into pages\n */\nexport function createPages() {\n  const size = parsePageSize(window.getComputedStyle(document.body).getPropertyValue('--page-size'));\n  document.documentElement.style.setProperty('--page-width', size[0]);\n  document.documentElement.style.setProperty('--page-height', size[1]);\n\n  const header = extractSelector('body > header');\n  const footer = extractSelector('body > footer');\n  let content = getStartingContent();\n  document.body.innerHTML = '';\n  let pageCount = 0;\n  let forceExtraPage = false;\n\n  while (forceExtraPage || !pageCount || (content && !emptyFragment(content))) {\n    pageCount += 1;\n\n    const page = newPage({ footer, header, pageNumber: pageCount });\n    if (content) {\n      page.appendChild(content);\n    }\n\n    const outerPage = page.closest('.page');\n    outerPage.dispatchEvent(new CustomEvent('create-page', { bubbles: true }));\n\n    let range = getOverflowingRange(page);\n\n    if (emptyRange(range)) {\n      // Last page\n      outerPage.dataset.lastPage = 'true';\n\n      // Recalculate overflow\n      range = getOverflowingRange(page);\n\n      if (forceExtraPage) {\n        break;\n      }\n\n      // Adding lastPage has created additional overflow\n      // Need to force an extra page for headers and footers\n      if (!emptyRange(range)) {\n        delete outerPage.dataset.lastPage;\n        forceExtraPage = true;\n        range = getOverflowingRange(page);\n      }\n    }\n\n    if (range) {\n      outerPage.dispatchEvent(new CustomEvent('before-fragmentation', { detail: range, bubbles: true }));\n      content = extract(range);\n      outerPage.dispatchEvent(new CustomEvent('after-fragmentation', { detail: content, bubbles: true }));\n    } else {\n      content = null;\n    }\n  }\n\n  document.body.style.setProperty('--page-count', pageCount);\n  document.body.dataset.pageCount = pageCount;\n  document.body.dispatchEvent(new CustomEvent('fragmentation-finished', { bubbles: true }));\n}\n","import { breakPointGenerator } from './generators/break_point_generator';\nimport { ruleDisablerGenerator } from './generators/rule_disabler_generator';\n\n/**\n * Returns the range overflowing an element\n */\nexport function getOverflowingRange(root) {\n  const breakPointIterator = breakPointGenerator(root);\n\n  const breakPoints = [];\n  let overflowing = false;\n  for (const breakPoint of breakPointIterator) {\n    // Always use the first forced breakpoint\n    if (!overflowing && breakPoint.force && !breakPoint.overflowing) {\n      const range = breakPoint.range();\n      if (range) {\n        return range;\n      }\n    }\n\n    if (!overflowing && breakPoint.overflowing) {\n      overflowing = true;\n\n      // Find the last useable breakpoint\n      // Retrying with relaxed rules\n      // https://www.w3.org/TR/css-break-3/#unforced-breaks\n      for (const disableRules of ruleDisablerGenerator(breakPoints)) {\n        for (const previousBreakPoint of breakPoints) {\n          const range = previousBreakPoint.range(disableRules);\n          if (range) {\n            return range;\n          }\n        }\n      }\n    }\n\n    if (!overflowing) {\n      breakPoints.unshift(breakPoint);\n    } else {\n      // No valid break point found.  We are overflowing\n      // Use the next break point with any result\n      const range = breakPoint.range({ disableRules: [1, 3, 4], avoidDepth: Infinity });\n      if (range) {\n        return range;\n      }\n    }\n  }\n\n  return null;\n}\n","import { nodeGenerator } from './node_generator';\nimport { RectFilter } from '../caches/rect_filter_cache';\nimport { BaseBreakPoint } from '../break_points/base_break_point';\nimport { InlineBreakPoint } from '../break_points/inline_break_point';\nimport { SiblingBreakPoint } from '../break_points/sibling_break_point';\nimport { NodeRules } from '../caches/node_rule_cache';\n\n/**\n * Yields permissible break points\n *\n * Based on CSS fragmentation Module level 3\n * https://www.w3.org/TR/css-break-3/\n */\nexport function* breakPointGenerator(root) {\n  const rectFilter = new RectFilter();\n  const nodeIterator = nodeGenerator(root, rectFilter);\n  const nodeRules = new NodeRules();\n\n  let currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n  let lastType;\n\n  for (const [type, node] of nodeIterator) {\n    switch (type) {\n      case 'enter': {\n        if (lastType === 'inline') {\n          const lastBreakPoint = currentBreakPoint;\n          yield currentBreakPoint;\n\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n          currentBreakPoint.trailingNodes.unshift(lastBreakPoint.lastNode);\n        }\n        currentBreakPoint.leadingNodes.push(node);\n        break;\n      }\n\n      case 'inline': {\n        if (lastType === 'exit') {\n          currentBreakPoint.leadingNodes.push(node);\n        }\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new InlineBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.nodes.push(node);\n        break;\n      }\n\n      case 'exit': {\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.trailingNodes.unshift(node);\n        break;\n      }\n\n      default:\n        throw new Error(`unexpected node type ${type}`);\n    }\n\n    lastType = type;\n  }\n\n  yield currentBreakPoint;\n\n  // If the last node is a text node and we are overflowing we may need to force a breakpoint\n  yield new BaseBreakPoint({ root, nodeRules, rectFilter });\n}\n","function* iterateLevel(walker, inline = false) {\n  do {\n    const { currentNode } = walker;\n\n    if (currentNode.nodeType === Node.TEXT_NODE) {\n      yield ['inline', currentNode];\n      continue;\n    }\n\n    // Inline can only be broken across text nodes\n    const isInline = inline || window.getComputedStyle(currentNode).display.includes('inline');\n\n    yield [isInline ? 'inline' : 'enter', currentNode];\n\n    if (window.getComputedStyle(currentNode).display === 'table-row') {\n      // do nothing - breaking within a table row is not supported\n    } else if (!currentNode.matches('picture,video,canvas,object,audio,embed,iframe,svg,math') && walker.firstChild()) {\n      yield* iterateLevel(walker, isInline);\n      walker.parentNode();\n    }\n\n    if (!isInline) {\n      yield ['exit', currentNode];\n    }\n  } while (walker.nextSibling());\n}\n\nconst types = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\n\n/**\n * SAX parser style DOM iterator\n *\n * Yields ['enter', node], ['text', node] and ['exit', node] values for a DOM structure\n */\nexport function* nodeGenerator(root, nodeFilter) {\n  const walker = document.createTreeWalker(root, types, nodeFilter);\n  if (!walker.nextNode()) {\n    return;\n  }\n  yield* iterateLevel(walker);\n}\n","export class RectFilter extends Map {\n  get(node) {\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    let rect;\n    if (node.nodeType === Node.TEXT_NODE) {\n      const range = new Range();\n      range.selectNode(node);\n      rect = range.getBoundingClientRect();\n    } else {\n      rect = node.getBoundingClientRect();\n    }\n    this.set(node, rect);\n    return rect;\n  }\n\n  acceptNode(node) {\n    const rect = this.get(node);\n    if (rect.height === 0) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    return NodeFilter.FILTER_ACCEPT;\n  }\n}\n","/**\n * Represents a possible break point\n *\n * The spec has three types of breakpoints:\n * - Class A: between siblings\n * - Class B: between line-boxes\n * - Class C: between a block and child content edges\n *\n * Only class A and B are supported\n */\nexport class BaseBreakPoint {\n  constructor({ rectFilter, nodeRules, root }) {\n    this.rectFilter = rectFilter;\n    this.nodeRules = nodeRules;\n    this.root = root;\n    this.type = 'base';\n  }\n\n  // A forced breakpoint\n  get force() {\n    return false;\n  }\n\n  // Breakpoint is set to avoid\n  get avoid() {\n    return false;\n  }\n\n  // Breakpoint is overflowing content area\n  get overflowing() {\n    return this.root.scrollHeight > this.root.clientHeight;\n  }\n\n  // Return range of overflowing content\n  range() {\n    return null;\n  }\n\n  // Internals\n  // ---------\n\n  get rootRect() {\n    return this.rectFilter.get(this.root);\n  }\n}\n","/**\n * Yields each line box as a range\n *\n * The selection API is the only API that gives any access to lineboxes\n *\n * Calculating though measuring ranges is slow and cannot cope\n * with different writing directions or unusual margins are paddings.\n */\nexport function* lineBoxGenerator(nodes) {\n  const selection = window.getSelection();\n\n  const firstText = nodes.find((node) => node.nodeType === Node.TEXT_NODE);\n  const lastText = [...nodes].reverse().find((node) => node.nodeType === Node.TEXT_NODE);\n\n  if (!firstText) {\n    return;\n  }\n\n  const textRange = new Range();\n  textRange.setStart(firstText, 0);\n  textRange.setEnd(lastText, lastText.data.length);\n\n  selection.empty();\n  selection.addRange(textRange);\n  selection.collapseToStart();\n\n  let lastRange = null;\n\n  while (true) {\n    selection.modify('extend', 'forward', 'line');\n\n    const lineRange = selection.getRangeAt(0);\n\n    if (lastRange) {\n      lineRange.setStart(lastRange.endContainer, lastRange.endOffset);\n    }\n\n    if (lineRange.collapsed) {\n      return;\n    }\n\n    // Chrome gets stuck at full width inline blocks\n    // So jump end to the start of the next text node\n    if (lineRange.endOffset === 0 && lineRange.endContainer.nodeType === Node.ELEMENT_NODE) {\n      const node = nodes.find((item) => (\n        item.nodeType === Node.TEXT_NODE\n          && item !== lineRange.endContainer\n          && lineRange.comparePoint(item, 0) === 1\n      ));\n      if (node) {\n        lineRange.setEndBefore(node);\n      }\n    }\n\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === -1) {\n      lineRange.setEnd(textRange.endContainer, textRange.endOffset);\n    }\n\n    // Stuck protection\n    if (lastRange && lineRange.compareBoundaryPoints(Range.START_TO_START, lastRange) === 0) {\n      break;\n    }\n\n    yield lineRange;\n\n    // At end of the text range\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === 0) {\n      break;\n    }\n\n    lastRange = lineRange.cloneRange();\n  }\n}\n","import { BaseBreakPoint } from './base_break_point';\nimport { lineBoxGenerator } from '../generators/line_box_generator';\n\nfunction calculateBottomSpace(container) {\n  const style = window.getComputedStyle(container);\n  const size = (parseFloat(style.paddingBottom) || 0)\n    + (parseFloat(style.borderBottomWidth) || 0)\n    + (parseFloat(style.marginBottom) || 0);\n\n  return Math.ceil(Math.max(size, 0));\n}\n\n/**\n * Represents a class B breakpoint\n */\nexport class InlineBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.nodes = [];\n    this.type = 'inline';\n  }\n\n  get overflowing() {\n    const rect = this.rectFilter.get(this.firstNode);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { widows, orphans } = this.containerRules;\n    if (widows === 0 && orphans === 0) {\n      return null;\n    }\n\n    if (!(disableRules.includes(4) && this.containerRules.breakInsideAvoid <= avoidDepth)\n      && this.containerRules.breakInsideAvoid\n    ) {\n      return null;\n    }\n\n    const lineBoxRange = this.findLineBoxRange(disableRules.includes(3));\n    const overflowingNodeRange = this.findFirstOverflowingNodeRange();\n\n    let overflowing = lineBoxRange || overflowingNodeRange;\n\n    if (lineBoxRange && overflowingNodeRange) {\n      if (lineBoxRange.compareBoundaryPoints(Range.START_TO_START, overflowingNodeRange) === 1) {\n        overflowing = lineBoxRange;\n      } else {\n        overflowing = overflowingNodeRange;\n      }\n    }\n\n    if (!overflowing) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStart(overflowing.startContainer, overflowing.startOffset);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  // Find the first overflowing linebox obeying widow and orphan rules\n  findLineBoxRange(relaxWidowsAndOrphans) {\n    let { widows, orphans } = this.containerRules;\n\n    widows = widows || 2;\n    orphans = orphans || 2;\n\n    if (relaxWidowsAndOrphans) {\n      widows = 1;\n      orphans = 1;\n    }\n\n    let lineBoxes = [];\n    let overflow = false;\n    let overflowIndex;\n\n    for (const lineBox of lineBoxGenerator(this.nodes)) {\n      if (!overflow) {\n        const rect = lineBox.getBoundingClientRect();\n        if (rect.bottom > (this.rootRect.bottom - this.bottomSpace)) {\n          overflow = lineBox;\n          overflowIndex = lineBoxes.length;\n        }\n      }\n      if (overflow && lineBoxes.length > overflowIndex + widows - 1) {\n        break;\n      }\n      lineBoxes.push(lineBox);\n    }\n\n    if (overflowIndex !== undefined) {\n      if (overflowIndex < orphans) {\n        // Insufficient orphans\n        return null;\n      }\n\n      lineBoxes = lineBoxes.slice(orphans);\n    }\n\n    if (lineBoxes.length === 1) {\n      return null;\n    }\n\n    return lineBoxes[lineBoxes.length - widows] || null;\n  }\n\n  // Find the first overflowing element\n  // If it is not a text node, and not the first node return it\n  findFirstOverflowingNodeRange() {\n    const foundNode = this.nodes.find((node) => {\n      const rect = this.rectFilter.get(node);\n      return rect.bottom > (this.rootRect.bottom - this.bottomSpace);\n    });\n\n    if (!foundNode || foundNode.nodeType === Node.TEXT_NODE || foundNode === this.firstNode) {\n      return null;\n    }\n    const range = new Range();\n    range.setStartBefore(foundNode);\n    return range;\n  }\n\n  get container() {\n    if (this._container) {\n      return this._container;\n    }\n    const range = new Range();\n    range.setStartBefore(this.firstNode);\n    range.setEndAfter(this.lastNode);\n    let container = range.commonAncestorContainer;\n    if (container.nodeType === Node.TEXT_NODE) {\n      container = container.parentNode;\n    }\n    this._container = container;\n    return container;\n  }\n\n  get bottomSpace() {\n    return (this._bottomSpace ??= calculateBottomSpace(this.container));\n  }\n\n  get containerRules() {\n    return (this._containerRules ??= this.nodeRules.get(this.container));\n  }\n\n  get firstNode() {\n    return this.nodes[0];\n  }\n\n  get lastNode() {\n    return this.nodes[this.nodes.length - 1];\n  }\n}\n","import { BaseBreakPoint } from './base_break_point';\n\n/**\n * Represents a class A breakpoint\n */\nexport class SiblingBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.leadingNodes = [];\n    this.trailingNodes = [];\n  }\n\n  get force() {\n    return (this._force ??= this.leadingNodes.some((node) => this.nodeRules.get(node).breakBefore === 'page')\n      || this.trailingNodes.some((node) => this.nodeRules.get(node).breakAfter === 'page'));\n  }\n\n  get overflowing() {\n    return this.leadingNodes.some(this.hasLeadingOverflow, this)\n      || this.trailingNodes.some(this.hasTrailingOverflow, this);\n  }\n\n  get avoid() {\n    return this.leadingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakBefore))\n      || this.trailingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakAfter));\n  }\n\n  get bottom() {\n    let bottom = 0;\n    for (const node of this.trailingNodes) {\n      const nodeBottom = this.getBottom(node);\n      if (nodeBottom < bottom) {\n        return bottom;\n      }\n      bottom = nodeBottom;\n    }\n    return bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { node, force, avoid } = this;\n\n    if (!node || node === Node.ELEMENT_NODE) {\n      return null;\n    }\n\n    if (!force && this.nodeRules.get(node).breakInsideParentAvoid > avoidDepth) {\n      return null;\n    }\n    if (!force && !disableRules.includes(1) && avoid) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStartAfter(node);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  get node() {\n    return this.trailingNodes[0];\n  }\n\n  hasLeadingOverflow(node) {\n    const rect = this.rectFilter.get(node);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  getBottom(node) {\n    const rect = this.rectFilter.get(node);\n    const style = node.nodeType === Node.ELEMENT_NODE ? window.getComputedStyle(node) : {};\n    return Math.ceil(\n      rect.bottom + (parseFloat(style.marginBottom) || 0) + this.getParentMargins(node),\n    );\n  }\n\n  getParentMargins(node) {\n    let bottom = 0;\n    let cursor = node.parentNode;\n    while (cursor && !cursor.contains(this.root)) {\n      const style = window.getComputedStyle(cursor);\n      bottom += parseFloat(style.paddingBottom) || 0;\n      bottom += parseFloat(style.marginBottom) || 0;\n      bottom += parseFloat(style.borderBottomWidth) || 0;\n      cursor = cursor.parentNode;\n    }\n    return bottom;\n  }\n\n  hasTrailingOverflow(node) {\n    return this.getBottom(node) > Math.floor(this.rootRect.bottom);\n  }\n}\n","export class NodeRules extends Map {\n  get(node) {\n    if (node instanceof Text) {\n      return this.get(node.parentNode);\n    }\n    if (!(node instanceof Element)) {\n      // TODO: Don't go higher than the page root\n      return {\n        breakInsideAvoid: 0,\n        breakInsideParentAvoid: 0,\n        breakAfter: 'auto',\n        breakBefore: 'auto',\n        orphans: 2,\n        widows: 2,\n      };\n    }\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    const rule = this.findInheritedRule(node);\n    this.set(node, rule);\n    return rule;\n  }\n\n  maxDepth() {\n    return Math.max(...[...this.values()].map((r) => r.breakInsideAvoid));\n  }\n\n  findInheritedRule(node) {\n    const parentRule = this.get(node.parentNode);\n    const styles = window.getComputedStyle(node);\n    const breakInside = this.breakInside(node, styles);\n    return {\n      breakInsideAvoid: parentRule.breakInsideAvoid + (breakInside ? 1 : 0),\n      breakInsideParentAvoid: parentRule.breakInsideAvoid,\n      breakAfter: styles.getPropertyValue('break-after'),\n      breakBefore: styles.getPropertyValue('break-before'),\n      orphans: parseInt(styles.getPropertyValue('--orphans') || styles.getPropertyValue('orphans') || 2, 10),\n      widows: parseInt(styles.getPropertyValue('--widows') || styles.getPropertyValue('widows') || 2, 10),\n    };\n  }\n\n  breakInside(node, styles) {\n    return ['avoid', 'avoid-page'].includes(styles.getPropertyValue('break-inside'));\n  }\n}\n","function* depths(breakPoints) {\n  // The node rules are the same cached instance on every breakpoint\n  const max = breakPoints[0].nodeRules.maxDepth();\n  for (let i = 0; i <= max; i += 1) {\n    yield i;\n  }\n}\n\n/**\n * Yields rule disabling settings\n * See https://www.w3.org/TR/css-break-3/#unforced-breaks\n */\nexport function* ruleDisablerGenerator(breakPoints) {\n  // No rule disabling\n  yield { disableRules: [] };\n\n  yield { disableRules: [3] };\n\n  for (const avoidDepth of depths(breakPoints)) {\n    yield { disableRules: [3], avoidDepth };\n\n    // Also relax break-before and break-after\n    // While progressively relaxing more avoid rules\n    yield { disableRules: [1, 3], avoidDepth };\n\n    // Also relax break-inside on line boxes\n    yield { disableRules: [1, 3, 4], avoidDepth };\n  }\n}\n","const rNamedSize = /^(A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger|landscape|portrait)(?:\\s+(landscape|portrait)$)?/;\n\nconst SIZES = {\n  A5: ['148mm', '210mm'],\n  A4: ['210mm', '297mm'],\n  A3: ['297mm', '420mm'],\n  B5: ['176mm', '250mm'],\n  B4: ['250mm', '353mm'],\n  'JIS-B5': ['182mm', '257mm'],\n  'JIS-B4': ['257mm', '364mm'],\n  letter: ['8.5in', '11in'],\n  legal: ['8.5in', '14in'],\n  ledger: ['11in', '17in'],\n};\n\n// https://www.w3.org/TR/css-page-3/#page-size-prop\nexport function parsePageSize(size) {\n  size = size.trim(); // eslint-disable-line no-param-reassign\n  if (!size || size === 'auto') {\n    return SIZES.A4;\n  }\n  const match = rNamedSize.exec(size);\n  if (!match) {\n    const parts = size.split(/\\s+/);\n    if (parts.length === 1) {\n      parts.push(parts[0]);\n    }\n    return parts;\n  }\n  let [, namedSize, orientation] = match;\n  if (['portrait', 'landscape'].includes(namedSize)) {\n    orientation = namedSize;\n    namedSize = 'A4';\n  }\n  const matchedSize = [...SIZES[namedSize]];\n  if (orientation === 'landscape') {\n    matchedSize.reverse();\n  }\n  return matchedSize;\n}\n","import { TableExtractor } from './extractors/table_extractor';\nimport { ListExtractor } from './extractors/list_extractor';\nimport { FragmentedExtractor } from './extractors/fragmented_extractor';\n\n/**\n * Extract a range\n * If the range is part of a table\n *   - Clone headers\n *   - Switch the table to a fixed layout\n */\nexport function extract(range) {\n  const extractors = [new TableExtractor(), new ListExtractor(), new FragmentedExtractor()];\n  extractors.forEach((extractor) => extractor.before(range));\n  const contents = range.extractContents();\n  extractors.forEach((extractor) => extractor.after(contents));\n  return contents;\n}\n","/* eslint-disable no-bitwise, no-mixed-operators */\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n","import { uuid } from '../uuid';\n\nfunction fixTable(table) {\n  // If the table already has cols, don't add new ones\n  if (!table.querySelector('col')) {\n    const columns = [...table.rows[0].cells].reduce((total, cell) => total + cell.colSpan, 0);\n\n    for (let i = 0; i < columns; i += 1) {\n      const col = document.createElement('col');\n      col.dataset.fragmenationCol = true;\n      table.prepend(col);\n    }\n  }\n\n  // Fix the widths of the columns\n  [...table.querySelectorAll('col')].forEach((col) => {\n    const rect = col.getBoundingClientRect();\n    // eslint-disable-next-line no-param-reassign\n    col.style.width = `${rect.width}px`;\n  });\n}\n\nfunction findAndMarkTables(range) {\n  const tables = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('table');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    fixTable(cursor);\n    tables.push(cursor);\n    cursor = cursor.parentNode.closest('table');\n  }\n  return tables;\n}\n\nexport class TableExtractor {\n  before(range) {\n    this.tables = findAndMarkTables(range);\n  }\n\n  after(fragment) {\n    this.tables.forEach((table) => {\n      const newTable = fragment.querySelector(`table[data-fragmentation-uuid=\"${table.dataset.fragmentationUuid}\"]`);\n      if (!newTable) {\n        return;\n      }\n      // Remove fixed widths\n      [...table.querySelectorAll('col[data-fragmentation-col]')].forEach((col) => col.remove());\n      // Add in thead\n      if (!newTable.tHead && table.tHead) {\n        newTable.tHead = table.tHead.cloneNode(true);\n      }\n      // Remove duplicated uuid\n      delete newTable.dataset.fragmentationUuid;\n    });\n  }\n}\n","import { uuid } from '../uuid';\n\nfunction visibleListItem(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  return node.matches('li') && node.getBoundingClientRect().height > 0;\n}\n\nfunction findAndMarkLists(range) {\n  const lists = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('ol');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    lists.push(cursor);\n    if (cursor.reversed) {\n      const items = [...cursor.childNodes].filter(visibleListItem).length;\n      cursor.start = items;\n    }\n    cursor = cursor.parentNode.closest('ol');\n  }\n  return lists;\n}\n\nexport class ListExtractor {\n  before(range) {\n    this.lists = findAndMarkLists(range);\n  }\n\n  after(fragment) {\n    this.lists.forEach((list) => {\n      const items = [...list.childNodes].filter(visibleListItem).length;\n      const newList = fragment.querySelector(`ol[data-fragmentation-uuid=\"${list.dataset.fragmentationUuid}\"]`);\n      if (newList) {\n        if (newList.reversed) {\n          newList.start = list.start - items;\n        } else {\n          newList.start = list.start + items;\n        }\n        delete newList.dataset.fragmentationUuid;\n      }\n    });\n  }\n}\n","export class FragmentedExtractor {\n  before(range) {\n    const { startContainer } = range;\n    if (startContainer.nodeType === Node.ELEMENT_NODE && startContainer.matches('.page-content')) {\n      // Range is not inside an element\n      return;\n    }\n    let node = startContainer;\n    if (node.nodeType === Node.TEXT_NODE) {\n      node = node.parentNode;\n    }\n    while (node && !node.matches('.page-content')) {\n      node.dataset.fragmentedStart = 'true';\n      node = node.parentNode;\n    }\n  }\n\n  after(fragment) {\n    fragment.querySelectorAll('[data-fragmented-start=true]').forEach((node) => {\n      delete node.dataset.fragmentedStart;\n      node.dataset.fragmentedEnd = 'true';\n    });\n  }\n}\n","import { createPages } from './index';\n\nwindow.addEventListener('DOMContentLoaded', async () => {\n  document.body.setAttribute('aria-busy', 'true');\n});\n\n// Wait for everything to load\nwindow.addEventListener('load', async () => {\n  // Fonts aren't included in load ðŸ¤·\n  await document.fonts.ready;\n  // Fragment the pages\n  createPages();\n\n  document.body.setAttribute('aria-busy', 'false');\n\n  // Line boxes are found using the selection api\n  // Clear any selection and return to top\n  window.getSelection().empty();\n  window.scrollTo(0, 0);\n});\n"],"names":["size","window","getComputedStyle","document","body","getPropertyValue","documentElement","style","setProperty","header","$4a7c571b58e6582fd62652d207d05159$var$extractSelector","footer","content","main","querySelector","$4a7c571b58e6582fd62652d207d05159$var$childrenToFragment","remove","$4a7c571b58e6582fd62652d207d05159$var$getStartingContent","innerHTML","pageCount","forceExtraPage","$4a7c571b58e6582fd62652d207d05159$var$emptyFragment","page","$4a7c571b58e6582fd62652d207d05159$var$newPage","pageNumber","appendChild","outerPage","closest","dispatchEvent","CustomEvent","bubbles","range","$4a7c571b58e6582fd62652d207d05159$var$emptyRange","dataset","lastPage","detail","root","breakPointIterator","breakPoints","overflowing","breakPoint","force","disableRules","previousBreakPoint","avoidDepth","Infinity","unshift","rectFilter","nodeIterator","nodeRules","lastType","currentBreakPoint","type","node","lastBreakPoint","trailingNodes","lastNode","leadingNodes","push","nodes","Error","nodeFilter","walker","createTreeWalker","$4f16edbd6251c807bdb5d9ce5cc74fd5$var$types","nextNode","$4f16edbd6251c807bdb5d9ce5cc74fd5$var$iterateLevel","inline","currentNode","nodeType","Node","TEXT_NODE","isInline","display","includes","matches","firstChild","parentNode","nextSibling","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","$c53623d12b1b0c967e465215f4fd6e65$var$RectFilter","Map","get","this","has","super","rect","Range","selectNode","getBoundingClientRect","set","acceptNode","height","FILTER_REJECT","FILTER_ACCEPT","constructor","scrollHeight","clientHeight","selection","getSelection","firstText","find","lastText","reverse","textRange","setStart","setEnd","data","length","empty","addRange","collapseToStart","lastRange","modify","lineRange","getRangeAt","endContainer","endOffset","collapsed","ELEMENT_NODE","item","comparePoint","setEndBefore","compareBoundaryPoints","END_TO_END","START_TO_START","cloneRange","$c406cddf6c48f4edf55495d25ab05169$var$InlineBreakPoint","$7268ae07461f48db3acaedf687fef481$exports","BaseBreakPoint","args","firstNode","top","rootRect","bottom","widows","orphans","containerRules","breakInsideAvoid","lineBoxRange","findLineBoxRange","overflowingNodeRange","findFirstOverflowingNodeRange","startContainer","startOffset","setEndAfter","lastChild","relaxWidowsAndOrphans","overflowIndex","lineBoxes","overflow","lineBox","bottomSpace","undefined","slice","foundNode","setStartBefore","_container","container","commonAncestorContainer","_bottomSpace","parseFloat","paddingBottom","borderBottomWidth","marginBottom","Math","ceil","max","$c406cddf6c48f4edf55495d25ab05169$var$calculateBottomSpace","_containerRules","$a700e6ca3c0b0f69e559065f93b19f15$var$SiblingBreakPoint","_force","some","breakBefore","breakAfter","hasLeadingOverflow","hasTrailingOverflow","nodeBottom","getBottom","avoid","breakInsideParentAvoid","setStartAfter","getParentMargins","cursor","contains","floor","$c7a71d1e004d4605ccd8bb7b256c7a64$var$NodeRules","Text","Element","rule","findInheritedRule","maxDepth","values","map","r","parentRule","styles","breakInside","parseInt","i","$2b8bb29c49a25c1b9d23565cc723c2fb$var$depths","trim","$8eba52d9883ff9b0ef5fe5ed7a39e8c1$var$SIZES","A4","match","$8eba52d9883ff9b0ef5fe5ed7a39e8c1$var$rNamedSize","exec","parts","split","namedSize","orientation","matchedSize","A5","A3","B5","B4","JIS-B5","JIS-B4","letter","legal","ledger","extractors","forEach","extractor","before","contents","extractContents","after","replace","c","random","toString","$4edd3a1a0bf9f550509250d87c2ba2a9$var$fixTable","table","columns","rows","cells","reduce","total","cell","colSpan","col","createElement","fragmenationCol","prepend","querySelectorAll","width","tables","fragmentationUuid","$4edd3a1a0bf9f550509250d87c2ba2a9$var$findAndMarkTables","fragment","newTable","tHead","cloneNode","$9f14c10aa2d4a4d8f802276497143320$var$visibleListItem","lists","reversed","items","childNodes","filter","start","$9f14c10aa2d4a4d8f802276497143320$var$findAndMarkLists","list","newList","classList","add","setAttribute","concat","pageInner","pageHeader","pageContent","pageFooter","createDocumentFragment","Array","from","child","selector","hasChildNodes","cloneContents","fragmentedStart","fragmentedEnd","addEventListener","async","fonts","ready","scrollTo"],"version":3,"file":"auto.js.map"}