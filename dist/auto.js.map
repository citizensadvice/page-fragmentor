{"mappings":"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","sources":["./src/index.js","./src/get_overflowing_range.js","./src/generators/break_point_generator.js","./src/generators/node_generator.js","./src/caches/rect_filter_cache.js","./src/break_points/base_break_point.js","./src/generators/line_box_generator.js","./src/get_margin.js","./src/break_points/inline_break_point.js","./src/break_points/sibling_break_point.js","./src/caches/node_rule_cache.js","./src/generators/rule_disabler_generator.js","./src/parse_page_size.js","./src/extract.js","./src/uuid.js","./src/extractors/table_extractor.js","./src/extractors/list_extractor.js","./src/extractors/fragmented_extractor.js","./src/auto.js"],"sourcesContent":["import { getOverflowingRange } from './get_overflowing_range';\nimport { parsePageSize } from './parse_page_size';\nimport { extract } from './extract';\n\nfunction newPage({ footer, header, pageNumber }) {\n  const page = document.createElement('div');\n  page.classList.add('page');\n  page.setAttribute('role', 'region');\n  page.setAttribute('aria-label', `Page ${pageNumber}`);\n  page.setAttribute('data-page-number', pageNumber);\n  page.style.setProperty('--page-number', pageNumber);\n  document.body.appendChild(page);\n  const pageInner = document.createElement('div');\n  pageInner.classList.add('page-inner');\n  page.appendChild(pageInner);\n\n  if (header) {\n    const pageHeader = document.createElement('div');\n    pageHeader.classList.add('page-header');\n    pageInner.appendChild(pageHeader);\n    pageHeader.appendChild(header.cloneNode(true));\n  }\n\n  const pageContent = document.createElement('div');\n  pageContent.classList.add('page-content');\n  pageInner.appendChild(pageContent);\n\n  if (footer) {\n    const pageFooter = document.createElement('div');\n    pageFooter.classList.add('page-footer');\n    pageInner.appendChild(pageFooter);\n    pageFooter.appendChild(footer.cloneNode(true));\n  }\n  return pageContent;\n}\n\nfunction childrenToFragment(node) {\n  const fragment = document.createDocumentFragment();\n  Array.from(node.childNodes).forEach((child) => {\n    fragment.appendChild(child);\n  });\n  return fragment;\n}\n\nfunction getStartingContent() {\n  const main = document.querySelector('body > main');\n  const content = childrenToFragment(main || document.body);\n  main?.remove();\n  return content;\n}\n\nfunction extractSelector(selector) {\n  const node = document.querySelector(selector);\n  if (node) {\n    return childrenToFragment(node);\n  }\n  return null;\n}\n\nfunction emptyFragment(node) {\n  return !node.hasChildNodes()\n    || (node.childNodes.length === 1\n      && node.firstChild.nodeType === Node.TEXT_NODE\n      && !node.firstChild.data.trim()\n    );\n}\n\nfunction emptyRange(range) {\n  if (!range || range.collapsed || emptyFragment(range.cloneContents())) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Move the content into pages\n */\nexport function createPages() {\n  const size = parsePageSize(window.getComputedStyle(document.body).getPropertyValue('--page-size'));\n  document.documentElement.style.setProperty('--page-width', size[0]);\n  document.documentElement.style.setProperty('--page-height', size[1]);\n\n  const header = extractSelector('body > header');\n  const footer = extractSelector('body > footer');\n  let content = getStartingContent();\n  document.body.innerHTML = '';\n  let pageCount = 0;\n  let forceExtraPage = false;\n\n  while (forceExtraPage || !pageCount || (content && !emptyFragment(content))) {\n    pageCount += 1;\n\n    const page = newPage({ footer, header, pageNumber: pageCount });\n    if (content) {\n      page.appendChild(content);\n    }\n\n    const outerPage = page.closest('.page');\n    outerPage.dispatchEvent(new CustomEvent('create-page', { bubbles: true }));\n\n    let range = getOverflowingRange(page);\n\n    if (emptyRange(range)) {\n      // Last page\n      outerPage.dataset.lastPage = 'true';\n\n      // Recalculate overflow\n      range = getOverflowingRange(page);\n\n      if (forceExtraPage) {\n        break;\n      }\n\n      // Adding lastPage has created additional overflow\n      // Need to force an extra page for headers and footers\n      if (!emptyRange(range)) {\n        delete outerPage.dataset.lastPage;\n        forceExtraPage = true;\n        range = getOverflowingRange(page);\n      }\n    }\n\n    if (range) {\n      outerPage.dispatchEvent(new CustomEvent('before-fragmentation', { detail: range, bubbles: true }));\n      content = extract(range);\n      outerPage.dispatchEvent(new CustomEvent('after-fragmentation', { detail: content, bubbles: true }));\n    } else {\n      content = null;\n    }\n  }\n\n  document.body.style.setProperty('--page-count', pageCount);\n  document.body.dataset.pageCount = pageCount;\n  document.body.dispatchEvent(new CustomEvent('fragmentation-finished', { bubbles: true }));\n}\n","import { breakPointGenerator } from './generators/break_point_generator';\nimport { ruleDisablerGenerator } from './generators/rule_disabler_generator';\n\n/**\n * Returns the range overflowing an element\n */\nexport function getOverflowingRange(root) {\n  const breakPointIterator = breakPointGenerator(root);\n\n  const breakPoints = [];\n  let overflowing = false;\n  for (const breakPoint of breakPointIterator) {\n    // Always use the first forced breakpoint\n    if (!overflowing && breakPoint.force && !breakPoint.overflowing) {\n      const range = breakPoint.range();\n      if (range) {\n        return range;\n      }\n    }\n\n    if (!overflowing && breakPoint.overflowing) {\n      overflowing = true;\n\n      // Find the last useable breakpoint\n      // Retrying with relaxed rules\n      // https://www.w3.org/TR/css-break-3/#unforced-breaks\n      for (const disableRules of ruleDisablerGenerator(breakPoints)) {\n        for (const previousBreakPoint of breakPoints) {\n          const range = previousBreakPoint.range(disableRules);\n          if (range) {\n            return range;\n          }\n        }\n      }\n    }\n\n    if (!overflowing) {\n      breakPoints.unshift(breakPoint);\n    } else {\n      // No valid break point found.  We are overflowing\n      // Use the next break point with any result\n      const range = breakPoint.range({ disableRules: [1, 3, 4], avoidDepth: Infinity });\n      if (range) {\n        return range;\n      }\n    }\n  }\n\n  return null;\n}\n","import { nodeGenerator } from './node_generator';\nimport { RectFilter } from '../caches/rect_filter_cache';\nimport { BaseBreakPoint } from '../break_points/base_break_point';\nimport { InlineBreakPoint } from '../break_points/inline_break_point';\nimport { SiblingBreakPoint } from '../break_points/sibling_break_point';\nimport { NodeRules } from '../caches/node_rule_cache';\n\n/**\n * Yields permissible break points\n *\n * Based on CSS fragmentation Module level 3\n * https://www.w3.org/TR/css-break-3/\n */\nexport function* breakPointGenerator(root) {\n  const rectFilter = new RectFilter();\n  const nodeIterator = nodeGenerator(root, rectFilter);\n  const nodeRules = new NodeRules();\n\n  let currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n  let lastType;\n\n  for (const [type, node] of nodeIterator) {\n    switch (type) {\n      case 'enter': {\n        if (lastType === 'inline') {\n          const lastBreakPoint = currentBreakPoint;\n          yield currentBreakPoint;\n\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n          currentBreakPoint.trailingNodes.unshift(lastBreakPoint.lastNode);\n        }\n        currentBreakPoint.leadingNodes.push(node);\n        break;\n      }\n\n      case 'inline': {\n        if (lastType === 'exit') {\n          currentBreakPoint.leadingNodes.push(node);\n        }\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new InlineBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.nodes.push(node);\n        break;\n      }\n\n      case 'exit': {\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new SiblingBreakPoint({ root, nodeRules, rectFilter });\n        }\n        currentBreakPoint.trailingNodes.unshift(node);\n        break;\n      }\n\n      default:\n        throw new Error(`unexpected node type ${type}`);\n    }\n\n    lastType = type;\n  }\n\n  yield currentBreakPoint;\n\n  // If the last node is a text node and we are overflowing we may need to force a breakpoint\n  yield new BaseBreakPoint({ root, nodeRules, rectFilter });\n}\n","function* iterateLevel(walker, inline = false) {\n  do {\n    const { currentNode } = walker;\n\n    if (currentNode.nodeType === Node.TEXT_NODE) {\n      yield ['inline', currentNode];\n      continue;\n    }\n\n    // Inline can only be broken across text nodes\n    const isInline = inline || window.getComputedStyle(currentNode).display.includes('inline');\n\n    yield [isInline ? 'inline' : 'enter', currentNode];\n\n    if (window.getComputedStyle(currentNode).display === 'table-row') {\n      // do nothing - breaking within a table row is not supported\n    } else if (!currentNode.matches('picture,video,canvas,object,audio,embed,iframe,svg,math') && walker.firstChild()) {\n      yield* iterateLevel(walker, isInline);\n      walker.parentNode();\n    }\n\n    if (!isInline) {\n      yield ['exit', currentNode];\n    }\n  } while (walker.nextSibling());\n}\n\nconst types = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\n\n/**\n * SAX parser style DOM iterator\n *\n * Yields ['enter', node], ['text', node] and ['exit', node] values for a DOM structure\n */\nexport function* nodeGenerator(root, nodeFilter) {\n  const walker = document.createTreeWalker(root, types, nodeFilter);\n  if (!walker.nextNode()) {\n    return;\n  }\n  yield* iterateLevel(walker);\n}\n","export class RectFilter extends Map {\n  get(node) {\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    let rect;\n    if (node.nodeType === Node.TEXT_NODE) {\n      const range = new Range();\n      range.selectNode(node);\n      rect = range.getBoundingClientRect();\n    } else {\n      rect = node.getBoundingClientRect();\n    }\n    this.set(node, rect);\n    return rect;\n  }\n\n  acceptNode(node) {\n    const rect = this.get(node);\n    if (rect.height === 0) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    return NodeFilter.FILTER_ACCEPT;\n  }\n}\n","/**\n * Represents a possible break point\n *\n * The spec has three types of breakpoints:\n * - Class A: between siblings\n * - Class B: between line-boxes\n * - Class C: between a block and child content edges\n *\n * Only class A and B are supported\n */\nexport class BaseBreakPoint {\n  constructor({ rectFilter, nodeRules, root }) {\n    this.rectFilter = rectFilter;\n    this.nodeRules = nodeRules;\n    this.root = root;\n    this.type = 'base';\n  }\n\n  // A forced breakpoint\n  get force() {\n    return false;\n  }\n\n  // Breakpoint is set to avoid\n  get avoid() {\n    return false;\n  }\n\n  // Breakpoint is overflowing content area\n  get overflowing() {\n    return this.root.scrollHeight > this.root.clientHeight;\n  }\n\n  // Return range of overflowing content\n  range() {\n    return null;\n  }\n\n  // Internals\n  // ---------\n\n  get rootRect() {\n    return this.rectFilter.get(this.root);\n  }\n}\n","/**\n * Yields each line box as a range\n *\n * The selection API is the only API that gives any access to lineboxes\n *\n * Calculating though measuring ranges is slow and cannot cope\n * with different writing directions or unusual margins are paddings.\n */\nexport function* lineBoxGenerator(nodes) {\n  const selection = window.getSelection();\n\n  const firstText = nodes.find((node) => node.nodeType === Node.TEXT_NODE);\n  const lastText = [...nodes].reverse().find((node) => node.nodeType === Node.TEXT_NODE);\n\n  if (!firstText) {\n    return;\n  }\n\n  const textRange = new Range();\n  textRange.setStart(firstText, 0);\n  textRange.setEnd(lastText, lastText.data.length);\n\n  selection.empty();\n  selection.addRange(textRange);\n  selection.collapseToStart();\n\n  let lastRange = null;\n\n  while (true) {\n    selection.modify('extend', 'forward', 'line');\n\n    const lineRange = selection.getRangeAt(0);\n\n    if (lastRange) {\n      lineRange.setStart(lastRange.endContainer, lastRange.endOffset);\n    }\n\n    if (lineRange.collapsed) {\n      return;\n    }\n\n    // Chrome gets stuck at full width inline blocks\n    // So jump end to the start of the next text node\n    if (lineRange.endOffset === 0 && lineRange.endContainer.nodeType === Node.ELEMENT_NODE) {\n      const node = nodes.find((item) => (\n        item.nodeType === Node.TEXT_NODE\n          && item !== lineRange.endContainer\n          && lineRange.comparePoint(item, 0) === 1\n      ));\n      if (node) {\n        lineRange.setEndBefore(node);\n      }\n    }\n\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === -1) {\n      lineRange.setEnd(textRange.endContainer, textRange.endOffset);\n    }\n\n    // Stuck protection\n    if (lastRange && lineRange.compareBoundaryPoints(Range.START_TO_START, lastRange) === 0) {\n      break;\n    }\n\n    yield lineRange;\n\n    // At end of the text range\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === 0) {\n      break;\n    }\n\n    lastRange = lineRange.cloneRange();\n  }\n}\n","function getMeasurement(style, prop) {\n  return parseFloat(style.getPropertyValue(prop)) || 0;\n}\n\nfunction collapseMargins(style) {\n  return !getMeasurement(style, 'padding-bottom')\n    && !getMeasurement(style, 'border-bottom-width')\n    && !style.display.includes('inline')\n    && style.overflow === 'visible'\n    && style.float === 'none';\n}\n\nfunction collapsedMargins(margins) {\n  return Math.max(\n    0,\n    Math.max(0, ...margins.filter((v) => v >= 0))\n    + Math.min(0, ...margins.filter((v) => v < 0)),\n  );\n}\n\n/**\n * Calculate the space required by margins, padding and border of the ancestor elements\n */\nexport function getMargin(node, root, includeInner) {\n  let bottom = 0;\n  let cursor = node.parentNode;\n  let style = node.nodeType === Node.ELEMENT_NODE\n    ? window.getComputedStyle(node)\n    : { getPropertyValue: () => 0 };\n  let margins = [getMeasurement(style, 'margin-bottom')];\n\n  if (includeInner) {\n    bottom += getMeasurement(style, 'padding-bottom');\n    bottom += getMeasurement(style, 'border-bottom-width');\n  }\n\n  while (cursor && !cursor.contains(root)) {\n    style = window.getComputedStyle(cursor);\n    if (collapseMargins(style)) {\n      margins.push(getMeasurement(style, 'margin-bottom'));\n    } else {\n      bottom += collapsedMargins(margins);\n      margins = [getMeasurement(style, 'margin-bottom')];\n      bottom += getMeasurement(style, 'padding-bottom');\n      bottom += getMeasurement(style, 'border-bottom-width');\n    }\n    cursor = cursor.parentNode;\n  }\n  bottom += collapsedMargins(margins);\n  return bottom;\n}\n","import { BaseBreakPoint } from './base_break_point';\nimport { lineBoxGenerator } from '../generators/line_box_generator';\nimport { getMargin } from '../get_margin';\n\n/**\n * Represents a class B breakpoint\n */\nexport class InlineBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.nodes = [];\n    this.type = 'inline';\n  }\n\n  get overflowing() {\n    const rect = this.rectFilter.get(this.firstNode);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { widows, orphans } = this.containerRules;\n    if (widows === 0 && orphans === 0) {\n      return null;\n    }\n\n    if (!(disableRules.includes(4) && this.containerRules.breakInsideAvoid <= avoidDepth)\n      && this.containerRules.breakInsideAvoid\n    ) {\n      return null;\n    }\n\n    const lineBoxRange = this.findLineBoxRange(disableRules.includes(3));\n    const overflowingNodeRange = this.findFirstOverflowingNodeRange();\n\n    let overflowing = lineBoxRange || overflowingNodeRange;\n\n    if (lineBoxRange && overflowingNodeRange) {\n      if (lineBoxRange.compareBoundaryPoints(Range.START_TO_START, overflowingNodeRange) === 1) {\n        overflowing = lineBoxRange;\n      } else {\n        overflowing = overflowingNodeRange;\n      }\n    }\n\n    if (!overflowing) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStart(overflowing.startContainer, overflowing.startOffset);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  // Find the first overflowing linebox obeying widow and orphan rules\n  findLineBoxRange(relaxWidowsAndOrphans) {\n    let { widows, orphans } = this.containerRules;\n\n    widows = widows || 2;\n    orphans = orphans || 2;\n\n    if (relaxWidowsAndOrphans) {\n      widows = 1;\n      orphans = 1;\n    }\n\n    let lineBoxes = [];\n    let overflow = false;\n    let overflowIndex;\n\n    for (const lineBox of lineBoxGenerator(this.nodes)) {\n      if (!overflow) {\n        const rect = lineBox.getBoundingClientRect();\n        if (rect.bottom > (this.rootRect.bottom - this.bottomSpace)) {\n          overflow = lineBox;\n          overflowIndex = lineBoxes.length;\n        }\n      }\n      if (overflow && lineBoxes.length > overflowIndex + widows - 1) {\n        break;\n      }\n      lineBoxes.push(lineBox);\n    }\n\n    if (overflowIndex !== undefined) {\n      if (overflowIndex < orphans) {\n        // Insufficient orphans\n        return null;\n      }\n\n      lineBoxes = lineBoxes.slice(orphans);\n    }\n\n    if (lineBoxes.length === 1) {\n      return null;\n    }\n\n    return lineBoxes[lineBoxes.length - widows] || null;\n  }\n\n  // Find the first overflowing element\n  // If it is not a text node, and not the first node return it\n  findFirstOverflowingNodeRange() {\n    const foundNode = this.nodes.find((node) => {\n      const rect = this.rectFilter.get(node);\n      return rect.bottom > (this.rootRect.bottom - getMargin(node, this.root));\n    });\n\n    if (!foundNode || foundNode.nodeType === Node.TEXT_NODE || foundNode === this.firstNode) {\n      return null;\n    }\n    const range = new Range();\n    range.setStartBefore(foundNode);\n    return range;\n  }\n\n  get container() {\n    if (this._container) {\n      return this._container;\n    }\n    const range = new Range();\n    range.setStartBefore(this.firstNode);\n    range.setEndAfter(this.lastNode);\n    let container = range.commonAncestorContainer;\n    if (container.nodeType === Node.TEXT_NODE) {\n      container = container.parentNode;\n    }\n    this._container = container;\n    return container;\n  }\n\n  get bottomSpace() {\n    return (this._bottomSpace ??= getMargin(this.container, this.root, true));\n  }\n\n  get containerRules() {\n    return (this._containerRules ??= this.nodeRules.get(this.container));\n  }\n\n  get firstNode() {\n    return this.nodes[0];\n  }\n\n  get lastNode() {\n    return this.nodes[this.nodes.length - 1];\n  }\n}\n","import { BaseBreakPoint } from './base_break_point';\nimport { getMargin } from '../get_margin';\n\n/**\n * Represents a class A breakpoint\n */\nexport class SiblingBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.leadingNodes = [];\n    this.trailingNodes = [];\n  }\n\n  get force() {\n    return (this._force ??= this.leadingNodes.some((node) => this.nodeRules.get(node).breakBefore === 'page')\n      || this.trailingNodes.some((node) => this.nodeRules.get(node).breakAfter === 'page'));\n  }\n\n  get overflowing() {\n    return this.leadingNodes.some(this.hasLeadingOverflow, this)\n      || this.trailingNodes.some(this.hasTrailingOverflow, this);\n  }\n\n  get avoid() {\n    return this.leadingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakBefore))\n      || this.trailingNodes.some((node) => ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakAfter));\n  }\n\n  get bottom() {\n    let bottom = 0;\n    for (const node of this.trailingNodes) {\n      const nodeBottom = this.getBottom(node);\n      if (nodeBottom < bottom) {\n        return bottom;\n      }\n      bottom = nodeBottom;\n    }\n    return bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { node, force, avoid } = this;\n\n    if (!node || node === Node.ELEMENT_NODE) {\n      return null;\n    }\n\n    if (!force && this.nodeRules.get(node).breakInsideParentAvoid > avoidDepth) {\n      return null;\n    }\n    if (!force && !disableRules.includes(1) && avoid) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStartAfter(node);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  get node() {\n    return this.trailingNodes[0];\n  }\n\n  hasLeadingOverflow(node) {\n    const rect = this.rectFilter.get(node);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  getBottom(node) {\n    const rect = this.rectFilter.get(node);\n    return Math.ceil(\n      rect.bottom + getMargin(node, this.root),\n    );\n  }\n\n  hasTrailingOverflow(node) {\n    return this.getBottom(node) > Math.floor(this.rootRect.bottom);\n  }\n}\n","export class NodeRules extends Map {\n  get(node) {\n    if (node instanceof Text) {\n      return this.get(node.parentNode);\n    }\n    if (!(node instanceof Element)) {\n      // TODO: Don't go higher than the page root\n      return {\n        breakInsideAvoid: 0,\n        breakInsideParentAvoid: 0,\n        breakAfter: 'auto',\n        breakBefore: 'auto',\n        orphans: 2,\n        widows: 2,\n      };\n    }\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    const rule = this.findInheritedRule(node);\n    this.set(node, rule);\n    return rule;\n  }\n\n  maxDepth() {\n    return Math.max(...[...this.values()].map((r) => r.breakInsideAvoid));\n  }\n\n  findInheritedRule(node) {\n    const parentRule = this.get(node.parentNode);\n    const styles = window.getComputedStyle(node);\n    const breakInside = this.breakInside(node, styles);\n    return {\n      breakInsideAvoid: parentRule.breakInsideAvoid + (breakInside ? 1 : 0),\n      breakInsideParentAvoid: parentRule.breakInsideAvoid,\n      breakAfter: styles.getPropertyValue('break-after'),\n      breakBefore: styles.getPropertyValue('break-before'),\n      orphans: parseInt(styles.getPropertyValue('--orphans') || styles.getPropertyValue('orphans') || 2, 10),\n      widows: parseInt(styles.getPropertyValue('--widows') || styles.getPropertyValue('widows') || 2, 10),\n    };\n  }\n\n  breakInside(node, styles) {\n    return ['avoid', 'avoid-page'].includes(styles.getPropertyValue('break-inside'));\n  }\n}\n","function* depths(breakPoints) {\n  // The node rules are the same cached instance on every breakpoint\n  const max = breakPoints[0].nodeRules.maxDepth();\n  for (let i = 0; i <= max; i += 1) {\n    yield i;\n  }\n}\n\n/**\n * Yields rule disabling settings\n * See https://www.w3.org/TR/css-break-3/#unforced-breaks\n */\nexport function* ruleDisablerGenerator(breakPoints) {\n  // No rule disabling\n  yield { disableRules: [] };\n\n  yield { disableRules: [3] };\n\n  for (const avoidDepth of depths(breakPoints)) {\n    yield { disableRules: [3], avoidDepth };\n\n    // Also relax break-before and break-after\n    // While progressively relaxing more avoid rules\n    yield { disableRules: [1, 3], avoidDepth };\n\n    // Also relax break-inside on line boxes\n    yield { disableRules: [1, 3, 4], avoidDepth };\n  }\n}\n","const rNamedSize = /^(A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger|landscape|portrait)(?:\\s+(landscape|portrait)$)?/;\n\nconst SIZES = {\n  A5: ['148mm', '210mm'],\n  A4: ['210mm', '297mm'],\n  A3: ['297mm', '420mm'],\n  B5: ['176mm', '250mm'],\n  B4: ['250mm', '353mm'],\n  'JIS-B5': ['182mm', '257mm'],\n  'JIS-B4': ['257mm', '364mm'],\n  letter: ['8.5in', '11in'],\n  legal: ['8.5in', '14in'],\n  ledger: ['11in', '17in'],\n};\n\n// https://www.w3.org/TR/css-page-3/#page-size-prop\nexport function parsePageSize(size) {\n  size = size.trim(); // eslint-disable-line no-param-reassign\n  if (!size || size === 'auto') {\n    return SIZES.A4;\n  }\n  const match = rNamedSize.exec(size);\n  if (!match) {\n    const parts = size.split(/\\s+/);\n    if (parts.length === 1) {\n      parts.push(parts[0]);\n    }\n    return parts;\n  }\n  let [, namedSize, orientation] = match;\n  if (['portrait', 'landscape'].includes(namedSize)) {\n    orientation = namedSize;\n    namedSize = 'A4';\n  }\n  const matchedSize = [...SIZES[namedSize]];\n  if (orientation === 'landscape') {\n    matchedSize.reverse();\n  }\n  return matchedSize;\n}\n","import { TableExtractor } from './extractors/table_extractor';\nimport { ListExtractor } from './extractors/list_extractor';\nimport { FragmentedExtractor } from './extractors/fragmented_extractor';\n\n/**\n * Extract a range\n * If the range is part of a table\n *   - Clone headers\n *   - Switch the table to a fixed layout\n */\nexport function extract(range) {\n  const extractors = [new TableExtractor(), new ListExtractor(), new FragmentedExtractor()];\n  extractors.forEach((extractor) => extractor.before(range));\n  const contents = range.extractContents();\n  extractors.forEach((extractor) => extractor.after(contents));\n  return contents;\n}\n","/* eslint-disable no-bitwise, no-mixed-operators */\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n","import { uuid } from '../uuid';\n\nfunction fixTable(table) {\n  // If the table already has cols, don't add new ones\n  if (!table.querySelector('col')) {\n    const columns = [...table.rows[0].cells].reduce((total, cell) => total + cell.colSpan, 0);\n\n    for (let i = 0; i < columns; i += 1) {\n      const col = document.createElement('col');\n      col.dataset.fragmenationCol = true;\n      table.prepend(col);\n    }\n  }\n\n  // Fix the widths of the columns\n  [...table.querySelectorAll('col')].forEach((col) => {\n    const rect = col.getBoundingClientRect();\n    // eslint-disable-next-line no-param-reassign\n    col.style.width = `${rect.width}px`;\n  });\n}\n\nfunction findAndMarkTables(range) {\n  const tables = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('table');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    fixTable(cursor);\n    tables.push(cursor);\n    cursor = cursor.parentNode.closest('table');\n  }\n  return tables;\n}\n\nexport class TableExtractor {\n  before(range) {\n    this.tables = findAndMarkTables(range);\n  }\n\n  after(fragment) {\n    this.tables.forEach((table) => {\n      const newTable = fragment.querySelector(`table[data-fragmentation-uuid=\"${table.dataset.fragmentationUuid}\"]`);\n      if (!newTable) {\n        return;\n      }\n      // Remove fixed widths\n      [...table.querySelectorAll('col[data-fragmentation-col]')].forEach((col) => col.remove());\n      // Add in thead\n      if (!newTable.tHead && table.tHead) {\n        newTable.tHead = table.tHead.cloneNode(true);\n      }\n      // Remove duplicated uuid\n      delete newTable.dataset.fragmentationUuid;\n    });\n  }\n}\n","import { uuid } from '../uuid';\n\nfunction visibleListItem(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  return node.matches('li') && node.getBoundingClientRect().height > 0;\n}\n\nfunction findAndMarkLists(range) {\n  const lists = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('ol');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    lists.push(cursor);\n    if (cursor.reversed) {\n      const items = [...cursor.childNodes].filter(visibleListItem).length;\n      cursor.start = items;\n    }\n    cursor = cursor.parentNode.closest('ol');\n  }\n  return lists;\n}\n\nexport class ListExtractor {\n  before(range) {\n    this.lists = findAndMarkLists(range);\n  }\n\n  after(fragment) {\n    this.lists.forEach((list) => {\n      const items = [...list.childNodes].filter(visibleListItem).length;\n      const newList = fragment.querySelector(`ol[data-fragmentation-uuid=\"${list.dataset.fragmentationUuid}\"]`);\n      if (newList) {\n        if (newList.reversed) {\n          newList.start = list.start - items;\n        } else {\n          newList.start = list.start + items;\n        }\n        delete newList.dataset.fragmentationUuid;\n      }\n    });\n  }\n}\n","export class FragmentedExtractor {\n  before(range) {\n    const { startContainer } = range;\n    if (startContainer.nodeType === Node.ELEMENT_NODE && startContainer.matches('.page-content')) {\n      // Range is not inside an element\n      return;\n    }\n    let node = startContainer;\n    if (node.nodeType === Node.TEXT_NODE) {\n      node = node.parentNode;\n    }\n    while (node && !node.matches('.page-content')) {\n      node.dataset.fragmentedStart = 'true';\n      node = node.parentNode;\n    }\n  }\n\n  after(fragment) {\n    fragment.querySelectorAll('[data-fragmented-start=true]').forEach((node) => {\n      delete node.dataset.fragmentedStart;\n      node.dataset.fragmentedEnd = 'true';\n    });\n  }\n}\n","import { createPages } from './index';\n\nwindow.addEventListener('DOMContentLoaded', async () => {\n  document.body.setAttribute('aria-busy', 'true');\n});\n\n// Wait for everything to load\nwindow.addEventListener('load', async () => {\n  // Fonts aren't included in load 🤷\n  await document.fonts.ready;\n  // Fragment the pages\n  createPages();\n\n  document.body.setAttribute('aria-busy', 'false');\n\n  // Line boxes are found using the selection api\n  // Clear any selection and return to top\n  window.getSelection().empty();\n  window.scrollTo(0, 0);\n});\n"],"names":["size","window","getComputedStyle","document","body","getPropertyValue","documentElement","style","setProperty","header","$4a7c571b58e6582fd62652d207d05159$var$extractSelector","footer","content","main","querySelector","$4a7c571b58e6582fd62652d207d05159$var$childrenToFragment","remove","$4a7c571b58e6582fd62652d207d05159$var$getStartingContent","innerHTML","pageCount","forceExtraPage","$4a7c571b58e6582fd62652d207d05159$var$emptyFragment","page","$4a7c571b58e6582fd62652d207d05159$var$newPage","pageNumber","appendChild","outerPage","closest","dispatchEvent","CustomEvent","bubbles","range","$4a7c571b58e6582fd62652d207d05159$var$emptyRange","dataset","lastPage","detail","root","breakPointIterator","breakPoints","overflowing","breakPoint","force","disableRules","previousBreakPoint","avoidDepth","Infinity","unshift","rectFilter","nodeIterator","nodeRules","lastType","currentBreakPoint","type","node","lastBreakPoint","trailingNodes","lastNode","leadingNodes","push","nodes","Error","nodeFilter","walker","createTreeWalker","$4f16edbd6251c807bdb5d9ce5cc74fd5$var$types","nextNode","$4f16edbd6251c807bdb5d9ce5cc74fd5$var$iterateLevel","inline","currentNode","nodeType","Node","TEXT_NODE","isInline","display","includes","matches","firstChild","parentNode","nextSibling","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","$c53623d12b1b0c967e465215f4fd6e65$var$RectFilter","Map","get","this","has","super","rect","Range","selectNode","getBoundingClientRect","set","acceptNode","height","FILTER_REJECT","FILTER_ACCEPT","constructor","scrollHeight","clientHeight","selection","getSelection","firstText","find","lastText","reverse","textRange","setStart","setEnd","data","length","empty","addRange","collapseToStart","lastRange","modify","lineRange","getRangeAt","endContainer","endOffset","collapsed","ELEMENT_NODE","item","comparePoint","setEndBefore","compareBoundaryPoints","END_TO_END","START_TO_START","cloneRange","includeInner","bottom","cursor","margins","$f16fd813d988b6cf324a3e96d38a4456$var$getMeasurement","contains","$f16fd813d988b6cf324a3e96d38a4456$var$collapseMargins","$f16fd813d988b6cf324a3e96d38a4456$var$collapsedMargins","prop","parseFloat","overflow","float","Math","max","filter","v","min","$c406cddf6c48f4edf55495d25ab05169$var$InlineBreakPoint","$7268ae07461f48db3acaedf687fef481$exports","BaseBreakPoint","args","firstNode","top","rootRect","widows","orphans","containerRules","breakInsideAvoid","lineBoxRange","findLineBoxRange","overflowingNodeRange","findFirstOverflowingNodeRange","startContainer","startOffset","setEndAfter","lastChild","relaxWidowsAndOrphans","overflowIndex","lineBoxes","lineBox","bottomSpace","undefined","slice","foundNode","setStartBefore","_container","container","commonAncestorContainer","_bottomSpace","_containerRules","$a700e6ca3c0b0f69e559065f93b19f15$var$SiblingBreakPoint","_force","some","breakBefore","breakAfter","hasLeadingOverflow","hasTrailingOverflow","nodeBottom","getBottom","avoid","breakInsideParentAvoid","setStartAfter","ceil","floor","$c7a71d1e004d4605ccd8bb7b256c7a64$var$NodeRules","Text","Element","rule","findInheritedRule","maxDepth","values","map","r","parentRule","styles","breakInside","parseInt","i","$2b8bb29c49a25c1b9d23565cc723c2fb$var$depths","trim","$8eba52d9883ff9b0ef5fe5ed7a39e8c1$var$SIZES","A4","match","$8eba52d9883ff9b0ef5fe5ed7a39e8c1$var$rNamedSize","exec","parts","split","namedSize","orientation","matchedSize","A5","A3","B5","B4","JIS-B5","JIS-B4","letter","legal","ledger","extractors","forEach","extractor","before","contents","extractContents","after","replace","c","random","toString","$4edd3a1a0bf9f550509250d87c2ba2a9$var$fixTable","table","columns","rows","cells","reduce","total","cell","colSpan","col","createElement","fragmenationCol","prepend","querySelectorAll","width","tables","fragmentationUuid","$4edd3a1a0bf9f550509250d87c2ba2a9$var$findAndMarkTables","fragment","newTable","tHead","cloneNode","$9f14c10aa2d4a4d8f802276497143320$var$visibleListItem","lists","reversed","items","childNodes","start","$9f14c10aa2d4a4d8f802276497143320$var$findAndMarkLists","list","newList","classList","add","setAttribute","concat","pageInner","pageHeader","pageContent","pageFooter","createDocumentFragment","Array","from","child","selector","hasChildNodes","cloneContents","fragmentedStart","fragmentedEnd","addEventListener","async","fonts","ready","scrollTo"],"version":3,"file":"auto.js.map"}