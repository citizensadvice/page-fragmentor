{"mappings":"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","sources":["<anon>","src/auto.js","src/index.js","src/get_overflowing_range.js","src/generators/break_point_generator.js","src/generators/node_generator.js","src/caches/rect_filter_cache.js","src/break_points/base_break_point.js","src/break_points/inline_break_point.js","src/generators/line_box_generator.js","src/get_margin.js","src/break_points/sibling_break_point.js","src/caches/node_rule_cache.js","src/generators/rule_disabler_generator.js","src/parse_page_size.js","src/extract.js","src/extractors/table_extractor.js","src/uuid.js","src/extractors/list_extractor.js","src/extractors/fragmented_extractor.js"],"sourcesContent":["function* $b8edfdf402ba7faa$var$iterateLevel(walker, inline = false) {\n    do {\n        const { currentNode: currentNode } = walker;\n        if (currentNode.nodeType === Node.TEXT_NODE) {\n            yield [\n                'inline',\n                currentNode\n            ];\n            continue;\n        }\n        // Inline can only be broken across text nodes\n        const isInline = inline || window.getComputedStyle(currentNode).display.includes('inline');\n        yield [\n            isInline ? 'inline' : 'enter',\n            currentNode\n        ];\n        if (window.getComputedStyle(currentNode).display === 'table-row') ;\n        else if (!currentNode.matches('picture,video,canvas,object,audio,embed,iframe,svg,math') && walker.firstChild()) {\n            yield* $b8edfdf402ba7faa$var$iterateLevel(walker, isInline);\n            walker.parentNode();\n        }\n        if (!isInline) yield [\n            'exit',\n            currentNode\n        ];\n    }while (walker.nextSibling());\n}\nconst $b8edfdf402ba7faa$var$types = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\nfunction* $b8edfdf402ba7faa$export$146769bef319e409(root, nodeFilter) {\n    const walker = document.createTreeWalker(root, $b8edfdf402ba7faa$var$types, nodeFilter);\n    if (!walker.nextNode()) return;\n    yield* $b8edfdf402ba7faa$var$iterateLevel(walker);\n}\n\n\nclass $dfb6e5ce33aff4a7$export$85f1a4080743d124 extends Map {\n    get(node) {\n        if (this.has(node)) return super.get(node);\n        let rect;\n        if (node.nodeType === Node.TEXT_NODE) {\n            const range = new Range();\n            range.selectNode(node);\n            rect = range.getBoundingClientRect();\n        } else rect = node.getBoundingClientRect();\n        this.set(node, rect);\n        return rect;\n    }\n    acceptNode(node) {\n        const rect = this.get(node);\n        if (rect.height === 0) return NodeFilter.FILTER_REJECT;\n        return NodeFilter.FILTER_ACCEPT;\n    }\n}\n\n\n/**\n * Represents a possible break point\n *\n * The spec has three types of breakpoints:\n * - Class A: between siblings\n * - Class B: between line-boxes\n * - Class C: between a block and child content edges\n *\n * Only class A and B are supported\n */ class $eff1b8fdc8ada8f0$export$605fe2834acd8b3d {\n    constructor({ rectFilter: rectFilter, nodeRules: nodeRules, root: root }){\n        this.rectFilter = rectFilter;\n        this.nodeRules = nodeRules;\n        this.root = root;\n        this.type = 'base';\n    }\n    // A forced breakpoint\n    get force() {\n        return false;\n    }\n    // Breakpoint is set to avoid\n    get avoid() {\n        return false;\n    }\n    // Breakpoint is overflowing content area\n    get overflowing() {\n        return this.root.scrollHeight > this.root.clientHeight;\n    }\n    // Return range of overflowing content\n    range() {\n        return null;\n    }\n    // Internals\n    // ---------\n    get rootRect() {\n        return this.rectFilter.get(this.root);\n    }\n}\n\n\n\n/**\n * Yields each line box as a range\n *\n * The selection API is the only API that gives any access to lineboxes\n *\n * Calculating though measuring ranges is slow and cannot cope\n * with different writing directions or unusual margins are paddings.\n */ function* $2a1c19376151cc13$export$a305012e00910036(nodes) {\n    const selection = window.getSelection();\n    const firstText = nodes.find((node)=>node.nodeType === Node.TEXT_NODE);\n    const lastText = [\n        ...nodes\n    ].reverse().find((node)=>node.nodeType === Node.TEXT_NODE);\n    if (!firstText) return;\n    const textRange = new Range();\n    textRange.setStart(firstText, 0);\n    textRange.setEnd(lastText, lastText.data.length);\n    selection.empty();\n    selection.addRange(textRange);\n    selection.collapseToStart();\n    let lastRange = null;\n    while(true){\n        selection.modify('extend', 'forward', 'line');\n        const lineRange = selection.getRangeAt(0);\n        if (lastRange) lineRange.setStart(lastRange.endContainer, lastRange.endOffset);\n        if (lineRange.collapsed) return;\n        // Chrome gets stuck at full width inline blocks\n        // So jump end to the start of the next text node\n        if (lineRange.endOffset === 0 && lineRange.endContainer.nodeType === Node.ELEMENT_NODE) {\n            const node = nodes.find((item)=>item.nodeType === Node.TEXT_NODE && item !== lineRange.endContainer && lineRange.comparePoint(item, 0) === 1);\n            if (node) lineRange.setEndBefore(node);\n        }\n        if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === -1) lineRange.setEnd(textRange.endContainer, textRange.endOffset);\n        // Stuck protection\n        if (lastRange && lineRange.compareBoundaryPoints(Range.START_TO_START, lastRange) === 0) break;\n        yield lineRange;\n        // At end of the text range\n        if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === 0) break;\n        lastRange = lineRange.cloneRange();\n    }\n}\n\n\nfunction $3694fd24b80d2a6e$var$getMeasurement(style, prop) {\n    return parseFloat(style.getPropertyValue(prop)) || 0;\n}\nfunction $3694fd24b80d2a6e$var$collapseMargins(style) {\n    return !$3694fd24b80d2a6e$var$getMeasurement(style, 'padding-bottom') && !$3694fd24b80d2a6e$var$getMeasurement(style, 'border-bottom-width') && !style.display.includes('inline') && style.overflow === 'visible' && style.float === 'none';\n}\nfunction $3694fd24b80d2a6e$var$collapsedMargins(margins) {\n    return Math.max(0, Math.max(0, ...margins.filter((v)=>v >= 0)) + Math.min(0, ...margins.filter((v)=>v < 0)));\n}\nfunction $3694fd24b80d2a6e$export$1bc603050bd777b1(node, root, includeInner) {\n    let bottom = 0;\n    let cursor = node.parentNode;\n    let style = node.nodeType === Node.ELEMENT_NODE ? window.getComputedStyle(node) : {\n        getPropertyValue: ()=>0\n    };\n    let margins = [\n        $3694fd24b80d2a6e$var$getMeasurement(style, 'margin-bottom')\n    ];\n    if (includeInner) {\n        bottom += $3694fd24b80d2a6e$var$getMeasurement(style, 'padding-bottom');\n        bottom += $3694fd24b80d2a6e$var$getMeasurement(style, 'border-bottom-width');\n    }\n    while(cursor && !cursor.contains(root)){\n        style = window.getComputedStyle(cursor);\n        if ($3694fd24b80d2a6e$var$collapseMargins(style)) margins.push($3694fd24b80d2a6e$var$getMeasurement(style, 'margin-bottom'));\n        else {\n            bottom += $3694fd24b80d2a6e$var$collapsedMargins(margins);\n            margins = [\n                $3694fd24b80d2a6e$var$getMeasurement(style, 'margin-bottom')\n            ];\n            bottom += $3694fd24b80d2a6e$var$getMeasurement(style, 'padding-bottom');\n            bottom += $3694fd24b80d2a6e$var$getMeasurement(style, 'border-bottom-width');\n        }\n        cursor = cursor.parentNode;\n    }\n    bottom += $3694fd24b80d2a6e$var$collapsedMargins(margins);\n    return bottom;\n}\n\n\nclass $87aa489adb451438$export$1243915ec9076a18 extends (0, $eff1b8fdc8ada8f0$export$605fe2834acd8b3d) {\n    constructor(...args){\n        super(...args);\n        this.nodes = [];\n        this.type = 'inline';\n    }\n    get overflowing() {\n        const rect = this.rectFilter.get(this.firstNode);\n        return rect.top > this.rootRect.bottom;\n    }\n    range({ disableRules: disableRules = [], avoidDepth: avoidDepth = 0 } = {}) {\n        const { widows: widows, orphans: orphans } = this.containerRules;\n        if (widows === 0 && orphans === 0) return null;\n        if (!(disableRules.includes(4) && this.containerRules.breakInsideAvoid <= avoidDepth) && this.containerRules.breakInsideAvoid) return null;\n        const lineBoxRange = this.findLineBoxRange(disableRules.includes(3));\n        const overflowingNodeRange = this.findFirstOverflowingNodeRange();\n        let overflowing = lineBoxRange || overflowingNodeRange;\n        if (lineBoxRange && overflowingNodeRange) {\n            if (lineBoxRange.compareBoundaryPoints(Range.START_TO_START, overflowingNodeRange) === 1) overflowing = lineBoxRange;\n            else overflowing = overflowingNodeRange;\n        }\n        if (!overflowing) return null;\n        const range = new Range();\n        range.setStart(overflowing.startContainer, overflowing.startOffset);\n        range.setEndAfter(this.root.lastChild);\n        return range;\n    }\n    // Internals\n    // ---------\n    // Find the first overflowing linebox obeying widow and orphan rules\n    findLineBoxRange(relaxWidowsAndOrphans) {\n        let { widows: widows, orphans: orphans } = this.containerRules;\n        widows = widows || 2;\n        orphans = orphans || 2;\n        if (relaxWidowsAndOrphans) {\n            widows = 1;\n            orphans = 1;\n        }\n        let lineBoxes = [];\n        let overflow = false;\n        let overflowIndex;\n        for (const lineBox of (0, $2a1c19376151cc13$export$a305012e00910036)(this.nodes)){\n            if (!overflow) {\n                const rect = lineBox.getBoundingClientRect();\n                if (rect.bottom > this.rootRect.bottom - this.bottomSpace) {\n                    overflow = lineBox;\n                    overflowIndex = lineBoxes.length;\n                }\n            }\n            if (overflow && lineBoxes.length > overflowIndex + widows - 1) break;\n            lineBoxes.push(lineBox);\n        }\n        if (overflowIndex !== undefined) {\n            if (overflowIndex < orphans) // Insufficient orphans\n            return null;\n            lineBoxes = lineBoxes.slice(orphans);\n        }\n        if (lineBoxes.length === 1) return null;\n        return lineBoxes[lineBoxes.length - widows] || null;\n    }\n    // Find the first overflowing element\n    // If it is not a text node, and not the first node return it\n    findFirstOverflowingNodeRange() {\n        const foundNode = this.nodes.find((node)=>{\n            const rect = this.rectFilter.get(node);\n            return rect.bottom > this.rootRect.bottom - (0, $3694fd24b80d2a6e$export$1bc603050bd777b1)(node, this.root);\n        });\n        if (!foundNode || foundNode.nodeType === Node.TEXT_NODE || foundNode === this.firstNode) return null;\n        const range = new Range();\n        range.setStartBefore(foundNode);\n        return range;\n    }\n    get container() {\n        if (this._container) return this._container;\n        const range = new Range();\n        range.setStartBefore(this.firstNode);\n        range.setEndAfter(this.lastNode);\n        let container = range.commonAncestorContainer;\n        if (container.nodeType === Node.TEXT_NODE) container = container.parentNode;\n        this._container = container;\n        return container;\n    }\n    get bottomSpace() {\n        return this._bottomSpace ??= (0, $3694fd24b80d2a6e$export$1bc603050bd777b1)(this.container, this.root, true);\n    }\n    get containerRules() {\n        return this._containerRules ??= this.nodeRules.get(this.container);\n    }\n    get firstNode() {\n        return this.nodes[0];\n    }\n    get lastNode() {\n        return this.nodes[this.nodes.length - 1];\n    }\n}\n\n\n\n\nclass $faae309a5ad2def9$export$30ad6d223e92737e extends (0, $eff1b8fdc8ada8f0$export$605fe2834acd8b3d) {\n    constructor(...args){\n        super(...args);\n        this.leadingNodes = [];\n        this.trailingNodes = [];\n    }\n    get force() {\n        return this._force ??= this.leadingNodes.some((node)=>this.nodeRules.get(node).breakBefore === 'page') || this.trailingNodes.some((node)=>this.nodeRules.get(node).breakAfter === 'page');\n    }\n    get overflowing() {\n        return this.leadingNodes.some(this.hasLeadingOverflow, this) || this.trailingNodes.some(this.hasTrailingOverflow, this);\n    }\n    get avoid() {\n        return this.leadingNodes.some((node)=>[\n                'avoid',\n                'avoid-page'\n            ].includes(this.nodeRules.get(node).breakBefore)) || this.trailingNodes.some((node)=>[\n                'avoid',\n                'avoid-page'\n            ].includes(this.nodeRules.get(node).breakAfter));\n    }\n    get bottom() {\n        let bottom = 0;\n        for (const node of this.trailingNodes){\n            const nodeBottom = this.getBottom(node);\n            if (nodeBottom < bottom) return bottom;\n            bottom = nodeBottom;\n        }\n        return bottom;\n    }\n    range({ disableRules: disableRules = [], avoidDepth: avoidDepth = 0 } = {}) {\n        const { node: node, force: force, avoid: avoid } = this;\n        if (!node || node === Node.ELEMENT_NODE) return null;\n        if (!force && this.nodeRules.get(node).breakInsideParentAvoid > avoidDepth) return null;\n        if (!force && !disableRules.includes(1) && avoid) return null;\n        const range = new Range();\n        range.setStartAfter(node);\n        range.setEndAfter(this.root.lastChild);\n        return range;\n    }\n    // Internals\n    // ---------\n    get node() {\n        return this.trailingNodes[0];\n    }\n    hasLeadingOverflow(node) {\n        const rect = this.rectFilter.get(node);\n        return rect.top > this.rootRect.bottom;\n    }\n    getBottom(node) {\n        const rect = this.rectFilter.get(node);\n        return Math.ceil(rect.bottom + (0, $3694fd24b80d2a6e$export$1bc603050bd777b1)(node, this.root));\n    }\n    hasTrailingOverflow(node) {\n        return this.getBottom(node) > Math.floor(this.rootRect.bottom);\n    }\n}\n\n\nclass $735fa0306754b434$export$247bac8acfb1da33 extends Map {\n    get(node) {\n        if (node instanceof Text) return this.get(node.parentNode);\n        if (!(node instanceof Element)) // TODO: Don't go higher than the page root\n        return {\n            breakInsideAvoid: 0,\n            breakInsideParentAvoid: 0,\n            breakAfter: 'auto',\n            breakBefore: 'auto',\n            orphans: 2,\n            widows: 2\n        };\n        if (this.has(node)) return super.get(node);\n        const rule = this.findInheritedRule(node);\n        this.set(node, rule);\n        return rule;\n    }\n    maxDepth() {\n        return Math.max(...[\n            ...this.values()\n        ].map((r)=>r.breakInsideAvoid));\n    }\n    findInheritedRule(node) {\n        const parentRule = this.get(node.parentNode);\n        const styles = window.getComputedStyle(node);\n        const breakInside = this.breakInside(node, styles);\n        return {\n            breakInsideAvoid: parentRule.breakInsideAvoid + (breakInside ? 1 : 0),\n            breakInsideParentAvoid: parentRule.breakInsideAvoid,\n            breakAfter: styles.getPropertyValue('break-after'),\n            breakBefore: styles.getPropertyValue('break-before'),\n            orphans: parseInt(styles.getPropertyValue('--orphans') || styles.getPropertyValue('orphans') || 2, 10),\n            widows: parseInt(styles.getPropertyValue('--widows') || styles.getPropertyValue('widows') || 2, 10)\n        };\n    }\n    breakInside(node, styles) {\n        return [\n            'avoid',\n            'avoid-page'\n        ].includes(styles.getPropertyValue('break-inside'));\n    }\n}\n\n\nfunction* $a201a4f6796033dd$export$b2e24cbcf4dbd900(root) {\n    const rectFilter = new (0, $dfb6e5ce33aff4a7$export$85f1a4080743d124)();\n    // Fix for older versions of safari\n    rectFilter.acceptNode = rectFilter.acceptNode.bind(rectFilter);\n    const nodeIterator = (0, $b8edfdf402ba7faa$export$146769bef319e409)(root, rectFilter);\n    const nodeRules = new (0, $735fa0306754b434$export$247bac8acfb1da33)();\n    let currentBreakPoint = new (0, $faae309a5ad2def9$export$30ad6d223e92737e)({\n        root: root,\n        nodeRules: nodeRules,\n        rectFilter: rectFilter\n    });\n    let lastType;\n    for (const [type, node] of nodeIterator){\n        switch(type){\n            case 'enter':\n                if (lastType === 'inline') {\n                    const lastBreakPoint = currentBreakPoint;\n                    yield currentBreakPoint;\n                    currentBreakPoint = new (0, $faae309a5ad2def9$export$30ad6d223e92737e)({\n                        root: root,\n                        nodeRules: nodeRules,\n                        rectFilter: rectFilter\n                    });\n                    currentBreakPoint.trailingNodes.unshift(lastBreakPoint.lastNode);\n                }\n                currentBreakPoint.leadingNodes.push(node);\n                break;\n            case 'inline':\n                if (lastType === 'exit') currentBreakPoint.leadingNodes.push(node);\n                if (lastType !== type) {\n                    yield currentBreakPoint;\n                    currentBreakPoint = new (0, $87aa489adb451438$export$1243915ec9076a18)({\n                        root: root,\n                        nodeRules: nodeRules,\n                        rectFilter: rectFilter\n                    });\n                }\n                currentBreakPoint.nodes.push(node);\n                break;\n            case 'exit':\n                if (lastType !== type) {\n                    yield currentBreakPoint;\n                    currentBreakPoint = new (0, $faae309a5ad2def9$export$30ad6d223e92737e)({\n                        root: root,\n                        nodeRules: nodeRules,\n                        rectFilter: rectFilter\n                    });\n                }\n                currentBreakPoint.trailingNodes.unshift(node);\n                break;\n            default:\n                throw new Error(`unexpected node type ${type}`);\n        }\n        lastType = type;\n    }\n    yield currentBreakPoint;\n    // If the last node is a text node and we are overflowing we may need to force a breakpoint\n    yield new (0, $eff1b8fdc8ada8f0$export$605fe2834acd8b3d)({\n        root: root,\n        nodeRules: nodeRules,\n        rectFilter: rectFilter\n    });\n}\n\n\nfunction* $ee885449d48a1404$var$depths(breakPoints) {\n    // The node rules are the same cached instance on every breakpoint\n    const max = breakPoints[0].nodeRules.maxDepth();\n    for(let i = 0; i <= max; i += 1)yield i;\n}\nfunction* $ee885449d48a1404$export$3c317435dc60a9cb(breakPoints) {\n    // No rule disabling\n    yield {\n        disableRules: []\n    };\n    yield {\n        disableRules: [\n            3\n        ]\n    };\n    for (const avoidDepth of $ee885449d48a1404$var$depths(breakPoints)){\n        yield {\n            disableRules: [\n                3\n            ],\n            avoidDepth: avoidDepth\n        };\n        // Also relax break-before and break-after\n        // While progressively relaxing more avoid rules\n        yield {\n            disableRules: [\n                1,\n                3\n            ],\n            avoidDepth: avoidDepth\n        };\n        // Also relax break-inside on line boxes\n        yield {\n            disableRules: [\n                1,\n                3,\n                4\n            ],\n            avoidDepth: avoidDepth\n        };\n    }\n}\n\n\nfunction $fe49902f9d8ccf83$export$313dd01e7845f064(root) {\n    const breakPointIterator = (0, $a201a4f6796033dd$export$b2e24cbcf4dbd900)(root);\n    const breakPoints = [];\n    let overflowing = false;\n    for (const breakPoint of breakPointIterator){\n        // Always use the first forced breakpoint\n        if (!overflowing && breakPoint.force && !breakPoint.overflowing) {\n            const range = breakPoint.range();\n            if (range) return range;\n        }\n        if (!overflowing && breakPoint.overflowing) {\n            overflowing = true;\n            // Find the last useable breakpoint\n            // Retrying with relaxed rules\n            // https://www.w3.org/TR/css-break-3/#unforced-breaks\n            for (const disableRules of (0, $ee885449d48a1404$export$3c317435dc60a9cb)(breakPoints))for (const previousBreakPoint of breakPoints){\n                const range = previousBreakPoint.range(disableRules);\n                if (range) return range;\n            }\n        }\n        if (!overflowing) breakPoints.unshift(breakPoint);\n        else {\n            // No valid break point found.  We are overflowing\n            // Use the next break point with any result\n            const range = breakPoint.range({\n                disableRules: [\n                    1,\n                    3,\n                    4\n                ],\n                avoidDepth: Infinity\n            });\n            if (range) return range;\n        }\n    }\n    return null;\n}\n\n\nconst $9de7e7abba1056fb$var$rNamedSize = /^(A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger|landscape|portrait)(?:\\s+(landscape|portrait)$)?/i;\nconst $9de7e7abba1056fb$var$SIZES = {\n    a5: [\n        '148mm',\n        '210mm'\n    ],\n    a4: [\n        '210mm',\n        '297mm'\n    ],\n    a3: [\n        '297mm',\n        '420mm'\n    ],\n    b5: [\n        '176mm',\n        '250mm'\n    ],\n    b4: [\n        '250mm',\n        '353mm'\n    ],\n    'jis-b5': [\n        '182mm',\n        '257mm'\n    ],\n    'jis-b4': [\n        '257mm',\n        '364mm'\n    ],\n    letter: [\n        '8.5in',\n        '11in'\n    ],\n    legal: [\n        '8.5in',\n        '14in'\n    ],\n    ledger: [\n        '11in',\n        '17in'\n    ]\n};\nfunction $9de7e7abba1056fb$export$c3fe24b58b951a74(size) {\n    size = size.trim().toLowerCase(); // eslint-disable-line no-param-reassign\n    if (!size || size === 'auto') return $9de7e7abba1056fb$var$SIZES.a4;\n    const match = $9de7e7abba1056fb$var$rNamedSize.exec(size);\n    if (!match) {\n        const parts = size.split(/\\s+/);\n        if (parts.length === 1) parts.push(parts[0]);\n        return parts;\n    }\n    let [, namedSize, orientation] = match;\n    if ([\n        'portrait',\n        'landscape'\n    ].includes(namedSize)) {\n        orientation = namedSize;\n        namedSize = 'a4';\n    }\n    const matchedSize = [\n        ...$9de7e7abba1056fb$var$SIZES[namedSize]\n    ];\n    if (orientation === 'landscape') matchedSize.reverse();\n    return matchedSize;\n}\n\n\nfunction $6d273f825332b49d$export$31b40729666a4ae0() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{\n        const r = Math.random() * 16 | 0;\n        const v = c === 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\n\n\nfunction $6e057cb0373e0a0b$var$fixTable(table) {\n    // If the table already has cols, don't add new ones\n    if (!table.querySelector('col')) {\n        const columns = [\n            ...table.rows[0].cells\n        ].reduce((total, cell)=>total + cell.colSpan, 0);\n        for(let i = 0; i < columns; i += 1){\n            const col = document.createElement('col');\n            col.dataset.fragmenationCol = true;\n            table.prepend(col);\n        }\n    }\n    // Fix the widths of the columns\n    [\n        ...table.querySelectorAll('col')\n    ].forEach((col)=>{\n        const { width: width } = col.getBoundingClientRect();\n        if (width) col.style.width = `${Math.ceil(width)}px`;\n    });\n}\nfunction $6e057cb0373e0a0b$var$findAndMarkTables(range) {\n    const tables = [];\n    let cursor = range.startContainer;\n    if (cursor.nodeType === Node.TEXT_NODE) cursor = cursor.parentNode;\n    cursor = cursor.closest('table');\n    while(cursor){\n        cursor.dataset.fragmentationUuid = (0, $6d273f825332b49d$export$31b40729666a4ae0)();\n        $6e057cb0373e0a0b$var$fixTable(cursor);\n        tables.push(cursor);\n        cursor = cursor.parentNode.closest('table');\n    }\n    return tables;\n}\nclass $6e057cb0373e0a0b$export$3f0ee2fb7540ee15 {\n    before(range) {\n        this.tables = $6e057cb0373e0a0b$var$findAndMarkTables(range);\n    }\n    after(fragment) {\n        this.tables.forEach((table)=>{\n            const newTable = fragment.querySelector(`table[data-fragmentation-uuid=\"${table.dataset.fragmentationUuid}\"]`);\n            if (!newTable) return;\n            // Remove fixed widths\n            [\n                ...table.querySelectorAll('col[data-fragmentation-col]')\n            ].forEach((col)=>col.remove());\n            // Add in thead\n            if (!newTable.tHead && table.tHead) newTable.tHead = table.tHead.cloneNode(true);\n            // Remove duplicated uuid\n            delete newTable.dataset.fragmentationUuid;\n        });\n    }\n}\n\n\n\nfunction $2c3fecc8d739938a$var$visibleListItem(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE) return false;\n    return node.matches('li') && node.getBoundingClientRect().height > 0;\n}\nfunction $2c3fecc8d739938a$var$findAndMarkLists(range) {\n    const lists = [];\n    let cursor = range.startContainer;\n    if (cursor.nodeType === Node.TEXT_NODE) cursor = cursor.parentNode;\n    cursor = cursor.closest('ol');\n    while(cursor){\n        cursor.dataset.fragmentationUuid = (0, $6d273f825332b49d$export$31b40729666a4ae0)();\n        lists.push(cursor);\n        if (cursor.reversed) {\n            const items = [\n                ...cursor.childNodes\n            ].filter($2c3fecc8d739938a$var$visibleListItem).length;\n            cursor.start = items;\n        }\n        cursor = cursor.parentNode.closest('ol');\n    }\n    return lists;\n}\nclass $2c3fecc8d739938a$export$d310e656d02ceb96 {\n    before(range) {\n        this.lists = $2c3fecc8d739938a$var$findAndMarkLists(range);\n    }\n    after(fragment) {\n        this.lists.forEach((list)=>{\n            const items = [\n                ...list.childNodes\n            ].filter($2c3fecc8d739938a$var$visibleListItem).length;\n            const newList = fragment.querySelector(`ol[data-fragmentation-uuid=\"${list.dataset.fragmentationUuid}\"]`);\n            if (newList) {\n                if (newList.reversed) newList.start = list.start - items;\n                else newList.start = list.start + items;\n                delete newList.dataset.fragmentationUuid;\n            }\n        });\n    }\n}\n\n\nclass $7d63c063614ff29c$export$9103e258b982dbff {\n    before(range) {\n        const { startContainer: startContainer } = range;\n        if (startContainer.nodeType === Node.ELEMENT_NODE && startContainer.matches('.page-content')) // Range is not inside an element\n        return;\n        let node = startContainer;\n        if (node.nodeType === Node.TEXT_NODE) node = node.parentNode;\n        while(node && !node.matches('.page-content')){\n            node.dataset.fragmentedStart = 'true';\n            node = node.parentNode;\n        }\n    }\n    after(fragment) {\n        fragment.querySelectorAll('[data-fragmented-start=true]').forEach((node)=>{\n            delete node.dataset.fragmentedStart;\n            node.dataset.fragmentedEnd = 'true';\n        });\n    }\n}\n\n\nfunction $7fca02a30a792c06$export$f9380c9a627682d3(range) {\n    const extractors = [\n        new (0, $6e057cb0373e0a0b$export$3f0ee2fb7540ee15)(),\n        new (0, $2c3fecc8d739938a$export$d310e656d02ceb96)(),\n        new (0, $7d63c063614ff29c$export$9103e258b982dbff)()\n    ];\n    extractors.forEach((extractor)=>extractor.before(range));\n    const contents = range.extractContents();\n    extractors.forEach((extractor)=>extractor.after(contents));\n    return contents;\n}\n\n\nfunction $240c5cb84f2d9597$var$newPage({ footer: footer, header: header, pageNumber: pageNumber }) {\n    const page = document.createElement('div');\n    page.classList.add('page');\n    page.setAttribute('role', 'region');\n    page.setAttribute('aria-label', `Page ${pageNumber}`);\n    page.setAttribute('data-page-number', pageNumber);\n    page.style.setProperty('--page-number', pageNumber);\n    document.body.appendChild(page);\n    const pageInner = document.createElement('div');\n    pageInner.classList.add('page-inner');\n    page.appendChild(pageInner);\n    if (header) {\n        const pageHeader = document.createElement('div');\n        pageHeader.classList.add('page-header');\n        pageInner.appendChild(pageHeader);\n        pageHeader.appendChild(header.cloneNode(true));\n    }\n    const pageContent = document.createElement('div');\n    pageContent.classList.add('page-content');\n    pageInner.appendChild(pageContent);\n    if (footer) {\n        const pageFooter = document.createElement('div');\n        pageFooter.classList.add('page-footer');\n        pageInner.appendChild(pageFooter);\n        pageFooter.appendChild(footer.cloneNode(true));\n    }\n    return pageContent;\n}\nfunction $240c5cb84f2d9597$var$childrenToFragment(node) {\n    const fragment = document.createDocumentFragment();\n    Array.from(node.childNodes).forEach((child)=>{\n        fragment.appendChild(child);\n    });\n    return fragment;\n}\nfunction $240c5cb84f2d9597$var$getStartingContent() {\n    const main = document.querySelector('body > main');\n    const content = $240c5cb84f2d9597$var$childrenToFragment(main || document.body);\n    main?.remove();\n    return content;\n}\nfunction $240c5cb84f2d9597$var$extractSelector(selector) {\n    const node = document.querySelector(selector);\n    if (node) return $240c5cb84f2d9597$var$childrenToFragment(node);\n    return null;\n}\nfunction $240c5cb84f2d9597$var$emptyFragment(node) {\n    return !node.hasChildNodes() || node.childNodes.length === 1 && node.firstChild.nodeType === Node.TEXT_NODE && !node.firstChild.data.trim();\n}\nfunction $240c5cb84f2d9597$var$emptyRange(range) {\n    if (!range || range.collapsed || $240c5cb84f2d9597$var$emptyFragment(range.cloneContents())) return true;\n    return false;\n}\nfunction $240c5cb84f2d9597$export$e9562cbc2a9880a8() {\n    const size = (0, $9de7e7abba1056fb$export$c3fe24b58b951a74)(window.getComputedStyle(document.body).getPropertyValue('--page-size'));\n    document.documentElement.style.setProperty('--page-width', size[0]);\n    document.documentElement.style.setProperty('--page-height', size[1]);\n    const header = $240c5cb84f2d9597$var$extractSelector('body > header');\n    const footer = $240c5cb84f2d9597$var$extractSelector('body > footer');\n    let content = $240c5cb84f2d9597$var$getStartingContent();\n    document.body.innerHTML = '';\n    let pageCount = 0;\n    let forceExtraPage = false;\n    while(forceExtraPage || !pageCount || content && !$240c5cb84f2d9597$var$emptyFragment(content)){\n        pageCount += 1;\n        const page = $240c5cb84f2d9597$var$newPage({\n            footer: footer,\n            header: header,\n            pageNumber: pageCount\n        });\n        if (content) page.appendChild(content);\n        const outerPage = page.closest('.page');\n        outerPage.dispatchEvent(new CustomEvent('create-page', {\n            bubbles: true\n        }));\n        let range = (0, $fe49902f9d8ccf83$export$313dd01e7845f064)(page);\n        if ($240c5cb84f2d9597$var$emptyRange(range)) {\n            // Last page\n            outerPage.dataset.lastPage = 'true';\n            // Recalculate overflow\n            range = (0, $fe49902f9d8ccf83$export$313dd01e7845f064)(page);\n            if (forceExtraPage) break;\n            // Adding lastPage has created additional overflow\n            // Need to force an extra page for headers and footers\n            if (!$240c5cb84f2d9597$var$emptyRange(range)) {\n                delete outerPage.dataset.lastPage;\n                forceExtraPage = true;\n                range = (0, $fe49902f9d8ccf83$export$313dd01e7845f064)(page);\n            }\n        }\n        if (range) {\n            outerPage.dispatchEvent(new CustomEvent('before-fragmentation', {\n                detail: range,\n                bubbles: true\n            }));\n            content = (0, $7fca02a30a792c06$export$f9380c9a627682d3)(range);\n            outerPage.dispatchEvent(new CustomEvent('after-fragmentation', {\n                detail: content,\n                bubbles: true\n            }));\n        } else content = null;\n    }\n    document.body.style.setProperty('--page-count', pageCount);\n    document.body.dataset.pageCount = pageCount;\n    document.body.dispatchEvent(new CustomEvent('fragmentation-finished', {\n        bubbles: true\n    }));\n}\n\n\nwindow.addEventListener('DOMContentLoaded', async ()=>{\n    document.body.setAttribute('aria-busy', 'true');\n});\n// Wait for everything to load\nwindow.addEventListener('load', async ()=>{\n    // Fonts aren't included in load ðŸ¤·\n    await document.fonts.ready;\n    // Fragment the pages\n    (0, $240c5cb84f2d9597$export$e9562cbc2a9880a8)();\n    document.body.setAttribute('aria-busy', 'false');\n    // Line boxes are found using the selection api\n    // Clear any selection and return to top\n    window.getSelection().empty();\n    window.scrollTo(0, 0);\n});\n\n\n//# sourceMappingURL=the_machine_stops.342b76a3.js.map\n","import { createPages } from './index.js';\n\nwindow.addEventListener('DOMContentLoaded', async () => {\n  document.body.setAttribute('aria-busy', 'true');\n});\n\n// Wait for everything to load\nwindow.addEventListener('load', async () => {\n  // Fonts aren't included in load ðŸ¤·\n  await document.fonts.ready;\n  // Fragment the pages\n  createPages();\n\n  document.body.setAttribute('aria-busy', 'false');\n\n  // Line boxes are found using the selection api\n  // Clear any selection and return to top\n  window.getSelection().empty();\n  window.scrollTo(0, 0);\n});\n","import { getOverflowingRange } from './get_overflowing_range.js';\nimport { parsePageSize } from './parse_page_size.js';\nimport { extract } from './extract.js';\n\nfunction newPage({ footer, header, pageNumber }) {\n  const page = document.createElement('div');\n  page.classList.add('page');\n  page.setAttribute('role', 'region');\n  page.setAttribute('aria-label', `Page ${pageNumber}`);\n  page.setAttribute('data-page-number', pageNumber);\n  page.style.setProperty('--page-number', pageNumber);\n  document.body.appendChild(page);\n  const pageInner = document.createElement('div');\n  pageInner.classList.add('page-inner');\n  page.appendChild(pageInner);\n\n  if (header) {\n    const pageHeader = document.createElement('div');\n    pageHeader.classList.add('page-header');\n    pageInner.appendChild(pageHeader);\n    pageHeader.appendChild(header.cloneNode(true));\n  }\n\n  const pageContent = document.createElement('div');\n  pageContent.classList.add('page-content');\n  pageInner.appendChild(pageContent);\n\n  if (footer) {\n    const pageFooter = document.createElement('div');\n    pageFooter.classList.add('page-footer');\n    pageInner.appendChild(pageFooter);\n    pageFooter.appendChild(footer.cloneNode(true));\n  }\n  return pageContent;\n}\n\nfunction childrenToFragment(node) {\n  const fragment = document.createDocumentFragment();\n  Array.from(node.childNodes).forEach((child) => {\n    fragment.appendChild(child);\n  });\n  return fragment;\n}\n\nfunction getStartingContent() {\n  const main = document.querySelector('body > main');\n  const content = childrenToFragment(main || document.body);\n  main?.remove();\n  return content;\n}\n\nfunction extractSelector(selector) {\n  const node = document.querySelector(selector);\n  if (node) {\n    return childrenToFragment(node);\n  }\n  return null;\n}\n\nfunction emptyFragment(node) {\n  return (\n    !node.hasChildNodes() ||\n    (node.childNodes.length === 1 &&\n      node.firstChild.nodeType === Node.TEXT_NODE &&\n      !node.firstChild.data.trim())\n  );\n}\n\nfunction emptyRange(range) {\n  if (!range || range.collapsed || emptyFragment(range.cloneContents())) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Move the content into pages\n */\nexport function createPages() {\n  const size = parsePageSize(\n    window.getComputedStyle(document.body).getPropertyValue('--page-size'),\n  );\n  document.documentElement.style.setProperty('--page-width', size[0]);\n  document.documentElement.style.setProperty('--page-height', size[1]);\n\n  const header = extractSelector('body > header');\n  const footer = extractSelector('body > footer');\n  let content = getStartingContent();\n  document.body.innerHTML = '';\n  let pageCount = 0;\n  let forceExtraPage = false;\n\n  while (forceExtraPage || !pageCount || (content && !emptyFragment(content))) {\n    pageCount += 1;\n\n    const page = newPage({ footer, header, pageNumber: pageCount });\n    if (content) {\n      page.appendChild(content);\n    }\n\n    const outerPage = page.closest('.page');\n    outerPage.dispatchEvent(new CustomEvent('create-page', { bubbles: true }));\n\n    let range = getOverflowingRange(page);\n\n    if (emptyRange(range)) {\n      // Last page\n      outerPage.dataset.lastPage = 'true';\n\n      // Recalculate overflow\n      range = getOverflowingRange(page);\n\n      if (forceExtraPage) {\n        break;\n      }\n\n      // Adding lastPage has created additional overflow\n      // Need to force an extra page for headers and footers\n      if (!emptyRange(range)) {\n        delete outerPage.dataset.lastPage;\n        forceExtraPage = true;\n        range = getOverflowingRange(page);\n      }\n    }\n\n    if (range) {\n      outerPage.dispatchEvent(\n        new CustomEvent('before-fragmentation', {\n          detail: range,\n          bubbles: true,\n        }),\n      );\n      content = extract(range);\n      outerPage.dispatchEvent(\n        new CustomEvent('after-fragmentation', {\n          detail: content,\n          bubbles: true,\n        }),\n      );\n    } else {\n      content = null;\n    }\n  }\n\n  document.body.style.setProperty('--page-count', pageCount);\n  document.body.dataset.pageCount = pageCount;\n  document.body.dispatchEvent(\n    new CustomEvent('fragmentation-finished', { bubbles: true }),\n  );\n}\n","import { breakPointGenerator } from './generators/break_point_generator.js';\nimport { ruleDisablerGenerator } from './generators/rule_disabler_generator.js';\n\n/**\n * Returns the range overflowing an element\n */\nexport function getOverflowingRange(root) {\n  const breakPointIterator = breakPointGenerator(root);\n\n  const breakPoints = [];\n  let overflowing = false;\n  for (const breakPoint of breakPointIterator) {\n    // Always use the first forced breakpoint\n    if (!overflowing && breakPoint.force && !breakPoint.overflowing) {\n      const range = breakPoint.range();\n      if (range) {\n        return range;\n      }\n    }\n\n    if (!overflowing && breakPoint.overflowing) {\n      overflowing = true;\n\n      // Find the last useable breakpoint\n      // Retrying with relaxed rules\n      // https://www.w3.org/TR/css-break-3/#unforced-breaks\n      for (const disableRules of ruleDisablerGenerator(breakPoints)) {\n        for (const previousBreakPoint of breakPoints) {\n          const range = previousBreakPoint.range(disableRules);\n          if (range) {\n            return range;\n          }\n        }\n      }\n    }\n\n    if (!overflowing) {\n      breakPoints.unshift(breakPoint);\n    } else {\n      // No valid break point found.  We are overflowing\n      // Use the next break point with any result\n      const range = breakPoint.range({\n        disableRules: [1, 3, 4],\n        avoidDepth: Infinity,\n      });\n      if (range) {\n        return range;\n      }\n    }\n  }\n\n  return null;\n}\n","import { nodeGenerator } from './node_generator.js';\nimport { RectFilter } from '../caches/rect_filter_cache.js';\nimport { BaseBreakPoint } from '../break_points/base_break_point.js';\nimport { InlineBreakPoint } from '../break_points/inline_break_point.js';\nimport { SiblingBreakPoint } from '../break_points/sibling_break_point.js';\nimport { NodeRules } from '../caches/node_rule_cache.js';\n\n/**\n * Yields permissible break points\n *\n * Based on CSS fragmentation Module level 3\n * https://www.w3.org/TR/css-break-3/\n */\nexport function* breakPointGenerator(root) {\n  const rectFilter = new RectFilter();\n  // Fix for older versions of safari\n  rectFilter.acceptNode = rectFilter.acceptNode.bind(rectFilter);\n  const nodeIterator = nodeGenerator(root, rectFilter);\n  const nodeRules = new NodeRules();\n\n  let currentBreakPoint = new SiblingBreakPoint({\n    root,\n    nodeRules,\n    rectFilter,\n  });\n  let lastType;\n\n  for (const [type, node] of nodeIterator) {\n    switch (type) {\n      case 'enter': {\n        if (lastType === 'inline') {\n          const lastBreakPoint = currentBreakPoint;\n          yield currentBreakPoint;\n\n          currentBreakPoint = new SiblingBreakPoint({\n            root,\n            nodeRules,\n            rectFilter,\n          });\n          currentBreakPoint.trailingNodes.unshift(lastBreakPoint.lastNode);\n        }\n        currentBreakPoint.leadingNodes.push(node);\n        break;\n      }\n\n      case 'inline': {\n        if (lastType === 'exit') {\n          currentBreakPoint.leadingNodes.push(node);\n        }\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new InlineBreakPoint({\n            root,\n            nodeRules,\n            rectFilter,\n          });\n        }\n        currentBreakPoint.nodes.push(node);\n        break;\n      }\n\n      case 'exit': {\n        if (lastType !== type) {\n          yield currentBreakPoint;\n          currentBreakPoint = new SiblingBreakPoint({\n            root,\n            nodeRules,\n            rectFilter,\n          });\n        }\n        currentBreakPoint.trailingNodes.unshift(node);\n        break;\n      }\n\n      default:\n        throw new Error(`unexpected node type ${type}`);\n    }\n\n    lastType = type;\n  }\n\n  yield currentBreakPoint;\n\n  // If the last node is a text node and we are overflowing we may need to force a breakpoint\n  yield new BaseBreakPoint({ root, nodeRules, rectFilter });\n}\n","function* iterateLevel(walker, inline = false) {\n  do {\n    const { currentNode } = walker;\n\n    if (currentNode.nodeType === Node.TEXT_NODE) {\n      yield ['inline', currentNode];\n      continue;\n    }\n\n    // Inline can only be broken across text nodes\n    const isInline =\n      inline || window.getComputedStyle(currentNode).display.includes('inline');\n\n    yield [isInline ? 'inline' : 'enter', currentNode];\n\n    if (window.getComputedStyle(currentNode).display === 'table-row') {\n      // do nothing - breaking within a table row is not supported\n    } else if (\n      !currentNode.matches(\n        'picture,video,canvas,object,audio,embed,iframe,svg,math',\n      ) &&\n      walker.firstChild()\n    ) {\n      yield* iterateLevel(walker, isInline);\n      walker.parentNode();\n    }\n\n    if (!isInline) {\n      yield ['exit', currentNode];\n    }\n  } while (walker.nextSibling());\n}\n\nconst types = NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT;\n\n/**\n * SAX parser style DOM iterator\n *\n * Yields ['enter', node], ['text', node] and ['exit', node] values for a DOM structure\n */\nexport function* nodeGenerator(root, nodeFilter) {\n  const walker = document.createTreeWalker(root, types, nodeFilter);\n  if (!walker.nextNode()) {\n    return;\n  }\n  yield* iterateLevel(walker);\n}\n","export class RectFilter extends Map {\n  get(node) {\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    let rect;\n    if (node.nodeType === Node.TEXT_NODE) {\n      const range = new Range();\n      range.selectNode(node);\n      rect = range.getBoundingClientRect();\n    } else {\n      rect = node.getBoundingClientRect();\n    }\n    this.set(node, rect);\n    return rect;\n  }\n\n  acceptNode(node) {\n    const rect = this.get(node);\n    if (rect.height === 0) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    return NodeFilter.FILTER_ACCEPT;\n  }\n}\n","/**\n * Represents a possible break point\n *\n * The spec has three types of breakpoints:\n * - Class A: between siblings\n * - Class B: between line-boxes\n * - Class C: between a block and child content edges\n *\n * Only class A and B are supported\n */\nexport class BaseBreakPoint {\n  constructor({ rectFilter, nodeRules, root }) {\n    this.rectFilter = rectFilter;\n    this.nodeRules = nodeRules;\n    this.root = root;\n    this.type = 'base';\n  }\n\n  // A forced breakpoint\n  get force() {\n    return false;\n  }\n\n  // Breakpoint is set to avoid\n  get avoid() {\n    return false;\n  }\n\n  // Breakpoint is overflowing content area\n  get overflowing() {\n    return this.root.scrollHeight > this.root.clientHeight;\n  }\n\n  // Return range of overflowing content\n  range() {\n    return null;\n  }\n\n  // Internals\n  // ---------\n\n  get rootRect() {\n    return this.rectFilter.get(this.root);\n  }\n}\n","import { BaseBreakPoint } from './base_break_point.js';\nimport { lineBoxGenerator } from '../generators/line_box_generator.js';\nimport { getMargin } from '../get_margin.js';\n\n/**\n * Represents a class B breakpoint\n */\nexport class InlineBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.nodes = [];\n    this.type = 'inline';\n  }\n\n  get overflowing() {\n    const rect = this.rectFilter.get(this.firstNode);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { widows, orphans } = this.containerRules;\n    if (widows === 0 && orphans === 0) {\n      return null;\n    }\n\n    if (\n      !(\n        disableRules.includes(4) &&\n        this.containerRules.breakInsideAvoid <= avoidDepth\n      ) &&\n      this.containerRules.breakInsideAvoid\n    ) {\n      return null;\n    }\n\n    const lineBoxRange = this.findLineBoxRange(disableRules.includes(3));\n    const overflowingNodeRange = this.findFirstOverflowingNodeRange();\n\n    let overflowing = lineBoxRange || overflowingNodeRange;\n\n    if (lineBoxRange && overflowingNodeRange) {\n      if (\n        lineBoxRange.compareBoundaryPoints(\n          Range.START_TO_START,\n          overflowingNodeRange,\n        ) === 1\n      ) {\n        overflowing = lineBoxRange;\n      } else {\n        overflowing = overflowingNodeRange;\n      }\n    }\n\n    if (!overflowing) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStart(overflowing.startContainer, overflowing.startOffset);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  // Find the first overflowing linebox obeying widow and orphan rules\n  findLineBoxRange(relaxWidowsAndOrphans) {\n    let { widows, orphans } = this.containerRules;\n\n    widows = widows || 2;\n    orphans = orphans || 2;\n\n    if (relaxWidowsAndOrphans) {\n      widows = 1;\n      orphans = 1;\n    }\n\n    let lineBoxes = [];\n    let overflow = false;\n    let overflowIndex;\n\n    for (const lineBox of lineBoxGenerator(this.nodes)) {\n      if (!overflow) {\n        const rect = lineBox.getBoundingClientRect();\n        if (rect.bottom > this.rootRect.bottom - this.bottomSpace) {\n          overflow = lineBox;\n          overflowIndex = lineBoxes.length;\n        }\n      }\n      if (overflow && lineBoxes.length > overflowIndex + widows - 1) {\n        break;\n      }\n      lineBoxes.push(lineBox);\n    }\n\n    if (overflowIndex !== undefined) {\n      if (overflowIndex < orphans) {\n        // Insufficient orphans\n        return null;\n      }\n\n      lineBoxes = lineBoxes.slice(orphans);\n    }\n\n    if (lineBoxes.length === 1) {\n      return null;\n    }\n\n    return lineBoxes[lineBoxes.length - widows] || null;\n  }\n\n  // Find the first overflowing element\n  // If it is not a text node, and not the first node return it\n  findFirstOverflowingNodeRange() {\n    const foundNode = this.nodes.find((node) => {\n      const rect = this.rectFilter.get(node);\n      return rect.bottom > this.rootRect.bottom - getMargin(node, this.root);\n    });\n\n    if (\n      !foundNode ||\n      foundNode.nodeType === Node.TEXT_NODE ||\n      foundNode === this.firstNode\n    ) {\n      return null;\n    }\n    const range = new Range();\n    range.setStartBefore(foundNode);\n    return range;\n  }\n\n  get container() {\n    if (this._container) {\n      return this._container;\n    }\n    const range = new Range();\n    range.setStartBefore(this.firstNode);\n    range.setEndAfter(this.lastNode);\n    let container = range.commonAncestorContainer;\n    if (container.nodeType === Node.TEXT_NODE) {\n      container = container.parentNode;\n    }\n    this._container = container;\n    return container;\n  }\n\n  get bottomSpace() {\n    return (this._bottomSpace ??= getMargin(this.container, this.root, true));\n  }\n\n  get containerRules() {\n    return (this._containerRules ??= this.nodeRules.get(this.container));\n  }\n\n  get firstNode() {\n    return this.nodes[0];\n  }\n\n  get lastNode() {\n    return this.nodes[this.nodes.length - 1];\n  }\n}\n","/**\n * Yields each line box as a range\n *\n * The selection API is the only API that gives any access to lineboxes\n *\n * Calculating though measuring ranges is slow and cannot cope\n * with different writing directions or unusual margins are paddings.\n */\nexport function* lineBoxGenerator(nodes) {\n  const selection = window.getSelection();\n\n  const firstText = nodes.find((node) => node.nodeType === Node.TEXT_NODE);\n  const lastText = [...nodes]\n    .reverse()\n    .find((node) => node.nodeType === Node.TEXT_NODE);\n\n  if (!firstText) {\n    return;\n  }\n\n  const textRange = new Range();\n  textRange.setStart(firstText, 0);\n  textRange.setEnd(lastText, lastText.data.length);\n\n  selection.empty();\n  selection.addRange(textRange);\n  selection.collapseToStart();\n\n  let lastRange = null;\n\n  while (true) {\n    selection.modify('extend', 'forward', 'line');\n\n    const lineRange = selection.getRangeAt(0);\n\n    if (lastRange) {\n      lineRange.setStart(lastRange.endContainer, lastRange.endOffset);\n    }\n\n    if (lineRange.collapsed) {\n      return;\n    }\n\n    // Chrome gets stuck at full width inline blocks\n    // So jump end to the start of the next text node\n    if (\n      lineRange.endOffset === 0 &&\n      lineRange.endContainer.nodeType === Node.ELEMENT_NODE\n    ) {\n      const node = nodes.find(\n        (item) =>\n          item.nodeType === Node.TEXT_NODE &&\n          item !== lineRange.endContainer &&\n          lineRange.comparePoint(item, 0) === 1,\n      );\n      if (node) {\n        lineRange.setEndBefore(node);\n      }\n    }\n\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === -1) {\n      lineRange.setEnd(textRange.endContainer, textRange.endOffset);\n    }\n\n    // Stuck protection\n    if (\n      lastRange &&\n      lineRange.compareBoundaryPoints(Range.START_TO_START, lastRange) === 0\n    ) {\n      break;\n    }\n\n    yield lineRange;\n\n    // At end of the text range\n    if (textRange.compareBoundaryPoints(Range.END_TO_END, lineRange) === 0) {\n      break;\n    }\n\n    lastRange = lineRange.cloneRange();\n  }\n}\n","function getMeasurement(style, prop) {\n  return parseFloat(style.getPropertyValue(prop)) || 0;\n}\n\nfunction collapseMargins(style) {\n  return (\n    !getMeasurement(style, 'padding-bottom') &&\n    !getMeasurement(style, 'border-bottom-width') &&\n    !style.display.includes('inline') &&\n    style.overflow === 'visible' &&\n    style.float === 'none'\n  );\n}\n\nfunction collapsedMargins(margins) {\n  return Math.max(\n    0,\n    Math.max(0, ...margins.filter((v) => v >= 0)) +\n      Math.min(0, ...margins.filter((v) => v < 0)),\n  );\n}\n\n/**\n * Calculate the space required by margins, padding and border of the ancestor elements\n */\nexport function getMargin(node, root, includeInner) {\n  let bottom = 0;\n  let cursor = node.parentNode;\n  let style =\n    node.nodeType === Node.ELEMENT_NODE\n      ? window.getComputedStyle(node)\n      : { getPropertyValue: () => 0 };\n  let margins = [getMeasurement(style, 'margin-bottom')];\n\n  if (includeInner) {\n    bottom += getMeasurement(style, 'padding-bottom');\n    bottom += getMeasurement(style, 'border-bottom-width');\n  }\n\n  while (cursor && !cursor.contains(root)) {\n    style = window.getComputedStyle(cursor);\n    if (collapseMargins(style)) {\n      margins.push(getMeasurement(style, 'margin-bottom'));\n    } else {\n      bottom += collapsedMargins(margins);\n      margins = [getMeasurement(style, 'margin-bottom')];\n      bottom += getMeasurement(style, 'padding-bottom');\n      bottom += getMeasurement(style, 'border-bottom-width');\n    }\n    cursor = cursor.parentNode;\n  }\n  bottom += collapsedMargins(margins);\n  return bottom;\n}\n","import { BaseBreakPoint } from './base_break_point.js';\nimport { getMargin } from '../get_margin.js';\n\n/**\n * Represents a class A breakpoint\n */\nexport class SiblingBreakPoint extends BaseBreakPoint {\n  constructor(...args) {\n    super(...args);\n    this.leadingNodes = [];\n    this.trailingNodes = [];\n  }\n\n  get force() {\n    return (this._force ??=\n      this.leadingNodes.some(\n        (node) => this.nodeRules.get(node).breakBefore === 'page',\n      ) ||\n      this.trailingNodes.some(\n        (node) => this.nodeRules.get(node).breakAfter === 'page',\n      ));\n  }\n\n  get overflowing() {\n    return (\n      this.leadingNodes.some(this.hasLeadingOverflow, this) ||\n      this.trailingNodes.some(this.hasTrailingOverflow, this)\n    );\n  }\n\n  get avoid() {\n    return (\n      this.leadingNodes.some((node) =>\n        ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakBefore),\n      ) ||\n      this.trailingNodes.some((node) =>\n        ['avoid', 'avoid-page'].includes(this.nodeRules.get(node).breakAfter),\n      )\n    );\n  }\n\n  get bottom() {\n    let bottom = 0;\n    for (const node of this.trailingNodes) {\n      const nodeBottom = this.getBottom(node);\n      if (nodeBottom < bottom) {\n        return bottom;\n      }\n      bottom = nodeBottom;\n    }\n    return bottom;\n  }\n\n  range({ disableRules = [], avoidDepth = 0 } = {}) {\n    const { node, force, avoid } = this;\n\n    if (!node || node === Node.ELEMENT_NODE) {\n      return null;\n    }\n\n    if (\n      !force &&\n      this.nodeRules.get(node).breakInsideParentAvoid > avoidDepth\n    ) {\n      return null;\n    }\n    if (!force && !disableRules.includes(1) && avoid) {\n      return null;\n    }\n\n    const range = new Range();\n    range.setStartAfter(node);\n    range.setEndAfter(this.root.lastChild);\n    return range;\n  }\n\n  // Internals\n  // ---------\n\n  get node() {\n    return this.trailingNodes[0];\n  }\n\n  hasLeadingOverflow(node) {\n    const rect = this.rectFilter.get(node);\n    return rect.top > this.rootRect.bottom;\n  }\n\n  getBottom(node) {\n    const rect = this.rectFilter.get(node);\n    return Math.ceil(rect.bottom + getMargin(node, this.root));\n  }\n\n  hasTrailingOverflow(node) {\n    return this.getBottom(node) > Math.floor(this.rootRect.bottom);\n  }\n}\n","export class NodeRules extends Map {\n  get(node) {\n    if (node instanceof Text) {\n      return this.get(node.parentNode);\n    }\n    if (!(node instanceof Element)) {\n      // TODO: Don't go higher than the page root\n      return {\n        breakInsideAvoid: 0,\n        breakInsideParentAvoid: 0,\n        breakAfter: 'auto',\n        breakBefore: 'auto',\n        orphans: 2,\n        widows: 2,\n      };\n    }\n    if (this.has(node)) {\n      return super.get(node);\n    }\n    const rule = this.findInheritedRule(node);\n    this.set(node, rule);\n    return rule;\n  }\n\n  maxDepth() {\n    return Math.max(...[...this.values()].map((r) => r.breakInsideAvoid));\n  }\n\n  findInheritedRule(node) {\n    const parentRule = this.get(node.parentNode);\n    const styles = window.getComputedStyle(node);\n    const breakInside = this.breakInside(node, styles);\n    return {\n      breakInsideAvoid: parentRule.breakInsideAvoid + (breakInside ? 1 : 0),\n      breakInsideParentAvoid: parentRule.breakInsideAvoid,\n      breakAfter: styles.getPropertyValue('break-after'),\n      breakBefore: styles.getPropertyValue('break-before'),\n      orphans: parseInt(\n        styles.getPropertyValue('--orphans') ||\n          styles.getPropertyValue('orphans') ||\n          2,\n        10,\n      ),\n      widows: parseInt(\n        styles.getPropertyValue('--widows') ||\n          styles.getPropertyValue('widows') ||\n          2,\n        10,\n      ),\n    };\n  }\n\n  breakInside(node, styles) {\n    return ['avoid', 'avoid-page'].includes(\n      styles.getPropertyValue('break-inside'),\n    );\n  }\n}\n","function* depths(breakPoints) {\n  // The node rules are the same cached instance on every breakpoint\n  const max = breakPoints[0].nodeRules.maxDepth();\n  for (let i = 0; i <= max; i += 1) {\n    yield i;\n  }\n}\n\n/**\n * Yields rule disabling settings\n * See https://www.w3.org/TR/css-break-3/#unforced-breaks\n */\nexport function* ruleDisablerGenerator(breakPoints) {\n  // No rule disabling\n  yield { disableRules: [] };\n\n  yield { disableRules: [3] };\n\n  for (const avoidDepth of depths(breakPoints)) {\n    yield { disableRules: [3], avoidDepth };\n\n    // Also relax break-before and break-after\n    // While progressively relaxing more avoid rules\n    yield { disableRules: [1, 3], avoidDepth };\n\n    // Also relax break-inside on line boxes\n    yield { disableRules: [1, 3, 4], avoidDepth };\n  }\n}\n","const rNamedSize =\n  /^(A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger|landscape|portrait)(?:\\s+(landscape|portrait)$)?/i;\n\nconst SIZES = {\n  a5: ['148mm', '210mm'],\n  a4: ['210mm', '297mm'],\n  a3: ['297mm', '420mm'],\n  b5: ['176mm', '250mm'],\n  b4: ['250mm', '353mm'],\n  'jis-b5': ['182mm', '257mm'],\n  'jis-b4': ['257mm', '364mm'],\n  letter: ['8.5in', '11in'],\n  legal: ['8.5in', '14in'],\n  ledger: ['11in', '17in'],\n};\n\n// https://www.w3.org/TR/css-page-3/#page-size-prop\nexport function parsePageSize(size) {\n  size = size.trim().toLowerCase(); // eslint-disable-line no-param-reassign\n  if (!size || size === 'auto') {\n    return SIZES.a4;\n  }\n  const match = rNamedSize.exec(size);\n  if (!match) {\n    const parts = size.split(/\\s+/);\n    if (parts.length === 1) {\n      parts.push(parts[0]);\n    }\n    return parts;\n  }\n  let [, namedSize, orientation] = match;\n  if (['portrait', 'landscape'].includes(namedSize)) {\n    orientation = namedSize;\n    namedSize = 'a4';\n  }\n  const matchedSize = [...SIZES[namedSize]];\n  if (orientation === 'landscape') {\n    matchedSize.reverse();\n  }\n  return matchedSize;\n}\n","import { TableExtractor } from './extractors/table_extractor.js';\nimport { ListExtractor } from './extractors/list_extractor.js';\nimport { FragmentedExtractor } from './extractors/fragmented_extractor.js';\n\n/**\n * Extract a range\n * If the range is part of a table\n *   - Clone headers\n *   - Switch the table to a fixed layout\n */\nexport function extract(range) {\n  const extractors = [\n    new TableExtractor(),\n    new ListExtractor(),\n    new FragmentedExtractor(),\n  ];\n  extractors.forEach((extractor) => extractor.before(range));\n  const contents = range.extractContents();\n  extractors.forEach((extractor) => extractor.after(contents));\n  return contents;\n}\n","import { uuid } from '../uuid.js';\n\nfunction fixTable(table) {\n  // If the table already has cols, don't add new ones\n  if (!table.querySelector('col')) {\n    const columns = [...table.rows[0].cells].reduce(\n      (total, cell) => total + cell.colSpan,\n      0,\n    );\n\n    for (let i = 0; i < columns; i += 1) {\n      const col = document.createElement('col');\n      col.dataset.fragmenationCol = true;\n      table.prepend(col);\n    }\n  }\n\n  // Fix the widths of the columns\n  [...table.querySelectorAll('col')].forEach((col) => {\n    const { width } = col.getBoundingClientRect();\n    if (width) {\n      col.style.width = `${Math.ceil(width)}px`;\n    }\n  });\n}\n\nfunction findAndMarkTables(range) {\n  const tables = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('table');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    fixTable(cursor);\n    tables.push(cursor);\n    cursor = cursor.parentNode.closest('table');\n  }\n  return tables;\n}\n\nexport class TableExtractor {\n  before(range) {\n    this.tables = findAndMarkTables(range);\n  }\n\n  after(fragment) {\n    this.tables.forEach((table) => {\n      const newTable = fragment.querySelector(\n        `table[data-fragmentation-uuid=\"${table.dataset.fragmentationUuid}\"]`,\n      );\n      if (!newTable) {\n        return;\n      }\n      // Remove fixed widths\n      [...table.querySelectorAll('col[data-fragmentation-col]')].forEach(\n        (col) => col.remove(),\n      );\n      // Add in thead\n      if (!newTable.tHead && table.tHead) {\n        newTable.tHead = table.tHead.cloneNode(true);\n      }\n      // Remove duplicated uuid\n      delete newTable.dataset.fragmentationUuid;\n    });\n  }\n}\n","export function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","import { uuid } from '../uuid.js';\n\nfunction visibleListItem(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  return node.matches('li') && node.getBoundingClientRect().height > 0;\n}\n\nfunction findAndMarkLists(range) {\n  const lists = [];\n  let cursor = range.startContainer;\n  if (cursor.nodeType === Node.TEXT_NODE) {\n    cursor = cursor.parentNode;\n  }\n  cursor = cursor.closest('ol');\n  while (cursor) {\n    cursor.dataset.fragmentationUuid = uuid();\n    lists.push(cursor);\n    if (cursor.reversed) {\n      const items = [...cursor.childNodes].filter(visibleListItem).length;\n      cursor.start = items;\n    }\n    cursor = cursor.parentNode.closest('ol');\n  }\n  return lists;\n}\n\nexport class ListExtractor {\n  before(range) {\n    this.lists = findAndMarkLists(range);\n  }\n\n  after(fragment) {\n    this.lists.forEach((list) => {\n      const items = [...list.childNodes].filter(visibleListItem).length;\n      const newList = fragment.querySelector(\n        `ol[data-fragmentation-uuid=\"${list.dataset.fragmentationUuid}\"]`,\n      );\n      if (newList) {\n        if (newList.reversed) {\n          newList.start = list.start - items;\n        } else {\n          newList.start = list.start + items;\n        }\n        delete newList.dataset.fragmentationUuid;\n      }\n    });\n  }\n}\n","export class FragmentedExtractor {\n  before(range) {\n    const { startContainer } = range;\n    if (\n      startContainer.nodeType === Node.ELEMENT_NODE &&\n      startContainer.matches('.page-content')\n    ) {\n      // Range is not inside an element\n      return;\n    }\n    let node = startContainer;\n    if (node.nodeType === Node.TEXT_NODE) {\n      node = node.parentNode;\n    }\n    while (node && !node.matches('.page-content')) {\n      node.dataset.fragmentedStart = 'true';\n      node = node.parentNode;\n    }\n  }\n\n  after(fragment) {\n    fragment\n      .querySelectorAll('[data-fragmented-start=true]')\n      .forEach((node) => {\n        delete node.dataset.fragmentedStart;\n        node.dataset.fragmentedEnd = 'true';\n      });\n  }\n}\n"],"names":["$b8edfdf402ba7faa$var$types","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","$dfb6e5ce33aff4a7$export$85f1a4080743d124","Map","get","node","rect","has","nodeType","Node","TEXT_NODE","range","Range","selectNode","getBoundingClientRect","set","acceptNode","height","FILTER_REJECT","FILTER_ACCEPT","$eff1b8fdc8ada8f0$export$605fe2834acd8b3d","rectFilter","nodeRules","root","type","force","avoid","overflowing","scrollHeight","clientHeight","rootRect","$3694fd24b80d2a6e$var$getMeasurement","style","prop","parseFloat","getPropertyValue","$3694fd24b80d2a6e$var$collapsedMargins","margins","Math","max","filter","v","min","$3694fd24b80d2a6e$export$1bc603050bd777b1","includeInner","bottom","cursor","parentNode","ELEMENT_NODE","window","getComputedStyle","contains","display","includes","overflow","float","push","$87aa489adb451438$export$1243915ec9076a18","args","nodes","firstNode","top","disableRules","avoidDepth","widows","orphans","containerRules","breakInsideAvoid","lineBoxRange","findLineBoxRange","overflowingNodeRange","findFirstOverflowingNodeRange","compareBoundaryPoints","START_TO_START","setStart","startContainer","startOffset","setEndAfter","lastChild","relaxWidowsAndOrphans","overflowIndex","lineBoxes","lineBox","selection","getSelection","firstText","find","lastText","reverse","textRange","setEnd","data","length","empty","addRange","collapseToStart","lastRange","modify","lineRange","getRangeAt","endContainer","endOffset","collapsed","item","comparePoint","setEndBefore","END_TO_END","cloneRange","bottomSpace","undefined","slice","foundNode","setStartBefore","container","_container","lastNode","commonAncestorContainer","_bottomSpace","_containerRules","$faae309a5ad2def9$export$30ad6d223e92737e","leadingNodes","trailingNodes","_force","some","breakBefore","breakAfter","hasLeadingOverflow","hasTrailingOverflow","nodeBottom","getBottom","breakInsideParentAvoid","setStartAfter","ceil","floor","$735fa0306754b434$export$247bac8acfb1da33","Text","Element","rule","findInheritedRule","maxDepth","values","map","r","parentRule","styles","breakInside","parseInt","$fe49902f9d8ccf83$export$313dd01e7845f064","breakPointIterator","lastType","bind","nodeIterator","nodeFilter","walker","document","createTreeWalker","nextNode","$b8edfdf402ba7faa$var$iterateLevel","inline","currentNode","isInline","matches","firstChild","nextSibling","currentBreakPoint","lastBreakPoint","unshift","Error","breakPoints","breakPoint","$ee885449d48a1404$var$depths","i","previousBreakPoint","Infinity","$9de7e7abba1056fb$var$rNamedSize","$9de7e7abba1056fb$var$SIZES","a5","a4","a3","b5","b4","letter","legal","ledger","$6d273f825332b49d$export$31b40729666a4ae0","replace","c","random","toString","$6e057cb0373e0a0b$export$3f0ee2fb7540ee15","before","tables","$6e057cb0373e0a0b$var$findAndMarkTables","closest","dataset","fragmentationUuid","$6e057cb0373e0a0b$var$fixTable","table","querySelector","columns","rows","cells","reduce","total","cell","colSpan","col","createElement","fragmenationCol","prepend","querySelectorAll","forEach","width","after","fragment","newTable","remove","tHead","cloneNode","$2c3fecc8d739938a$var$visibleListItem","$2c3fecc8d739938a$export$d310e656d02ceb96","lists","$2c3fecc8d739938a$var$findAndMarkLists","reversed","items","childNodes","start","list","newList","$7d63c063614ff29c$export$9103e258b982dbff","fragmentedStart","fragmentedEnd","$240c5cb84f2d9597$var$childrenToFragment","createDocumentFragment","Array","from","child","appendChild","$240c5cb84f2d9597$var$extractSelector","selector","$240c5cb84f2d9597$var$emptyFragment","hasChildNodes","trim","$240c5cb84f2d9597$var$emptyRange","cloneContents","addEventListener","body","setAttribute","fonts","ready","main","content","size","toLowerCase","match","exec","parts","split","namedSize","orientation","matchedSize","documentElement","setProperty","header","footer","innerHTML","pageCount","forceExtraPage","page","$240c5cb84f2d9597$var$newPage","pageNumber","classList","add","pageInner","pageHeader","pageContent","pageFooter","outerPage","dispatchEvent","CustomEvent","bubbles","lastPage","detail","extractors","extractor","contents","extractContents","scrollTo"],"version":3,"file":"the_machine_stops.342b76a3.js.map"}